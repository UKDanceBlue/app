# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

"""API response"""
interface AbstractGraphQLPaginatedResponse {
  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

"""The level of access a user has"""
enum AccessLevel {
  Admin
  Committee
  CommitteeChairOrCoordinator
  None
  Public
  SuperAdmin
  UKY
}

input AssignEntryToPersonInput {
  amount: Float!
}

"""The source of authentication"""
enum AuthSource {
  Anonymous
  Demo
  LinkBlue
  None
}

enum BatchType {
  ACH
  Check
  CreditCard
  DBFunds
  NonCash
  PayrollDeduction
  Transmittal
  Unknown
}

input BulkPersonInput {
  committee: CommitteeIdentifier
  email: EmailAddress!
  linkblue: NonEmptyString!
  name: NonEmptyString!
  role: CommitteeRole
}

input BulkTeamInput {
  captainLinkblues: [NonEmptyString!]
  legacyStatus: TeamLegacyStatus!
  memberLinkblues: [NonEmptyString!]
  name: NonEmptyString!
  type: TeamType!
}

"""The identifier for a committee"""
enum CommitteeIdentifier {
  communityDevelopmentCommittee
  corporateCommittee
  dancerRelationsCommittee
  familyRelationsCommittee
  fundraisingCommittee
  marketingCommittee
  miniMarathonsCommittee
  operationsCommittee
  overallCommittee
  programmingCommittee
  techCommittee
  viceCommittee
}

type CommitteeMembershipNode implements Node {
  committeeRole: CommitteeRole
  createdAt: DateTimeISO
  id: GlobalId!
  identifier: CommitteeIdentifier!
  person: PersonNode!
  position: MembershipPositionType!
  role: CommitteeRole!
  team: TeamNode!
  updatedAt: DateTimeISO
}

type CommitteeNode implements Node {
  createdAt: DateTimeISO
  id: GlobalId!
  identifier: CommitteeIdentifier!
  updatedAt: DateTimeISO
}

"""Roles within a committee"""
enum CommitteeRole {
  Chair
  Coordinator
  Member
}

type ConfigurationNode implements Node {
  createdAt: DateTimeISO
  id: GlobalId!
  key: String!
  updatedAt: DateTimeISO
  validAfter: DateTimeISO
  validUntil: DateTimeISO
  value: String!
}

input CreateConfigurationInput {
  key: String!
  validAfter: DateTimeISO
  validUntil: DateTimeISO
  value: String!
}

input CreateEventInput {
  description: NonEmptyString
  location: NonEmptyString
  occurrences: [CreateEventOccurrenceInput!]!
  summary: NonEmptyString
  title: NonEmptyString!
}

input CreateEventOccurrenceInput {
  fullDay: Boolean!
  interval: IntervalISOInput!
}

input CreateFeedInput {
  imageUuid: GlobalId
  textContent: NonEmptyString
  title: NonEmptyString!
}

input CreateImageInput {
  alt: NonEmptyString
  url: URL
}

input CreateMarathonHourInput {
  details: NonEmptyString
  durationInfo: NonEmptyString!
  shownStartingAt: DateTimeISO!
  title: NonEmptyString!
}

input CreateMarathonInput {
  endDate: DateTimeISO
  startDate: DateTimeISO
  year: NonEmptyString!
}

input CreatePersonInput {
  captainOf: [MemberOf!]! = []
  dbRole: DbRole @deprecated(reason: "DBRole can no longer be set directly")
  email: EmailAddress!
  linkblue: NonEmptyString
  memberOf: [MemberOf!]! = []
  name: NonEmptyString
}

input CreatePointEntryInput {
  comment: NonEmptyString
  opportunityUuid: GlobalId
  personFromUuid: GlobalId
  points: Int!
  teamUuid: GlobalId!
}

input CreatePointOpportunityInput {
  eventUuid: GlobalId
  marathonUuid: GlobalId!
  name: NonEmptyString!
  opportunityDate: DateTimeISO
  type: TeamType!
}

input CreateTeamInput {
  legacyStatus: TeamLegacyStatus!
  name: NonEmptyString!
  type: TeamType!
}

type DailyDepartmentNotificationBatchNode {
  batchNumber: String!
  batchType: BatchType!
  dailyDepartmentNotifications: [DailyDepartmentNotificationNode!]!
  id: GlobalId!
}

input DailyDepartmentNotificationInput {
  accountName: NonEmptyString!
  accountNumber: NonEmptyString!
  advFeeAmtPhil: Float
  advFeeAmtUnit: Float
  advFeeCcPhil: NonEmptyString
  advFeeCcUnit: NonEmptyString
  advFeeStatus: NonEmptyString
  batchId: NonEmptyString!
  behalfHonorMemorial: NonEmptyString
  combinedAmount: Float!
  combinedDonorName: NonEmptyString!
  combinedDonorSalutation: NonEmptyString!
  combinedDonorSort: NonEmptyString
  comment: NonEmptyString
  department: NonEmptyString
  divFirstGift: Boolean!
  division: NonEmptyString
  donor1Amount: Float
  donor1Constituency: NonEmptyString
  donor1Deceased: Boolean
  donor1Degrees: NonEmptyString
  donor1GiftKey: NonEmptyString
  donor1Id: NonEmptyString
  donor1Name: NonEmptyString
  donor1Pm: NonEmptyString
  donor1Relation: NonEmptyString
  donor1TitleBar: NonEmptyString
  donor2Amount: Float
  donor2Constituency: NonEmptyString
  donor2Deceased: Boolean
  donor2Degrees: NonEmptyString
  donor2GiftKey: NonEmptyString
  donor2Id: NonEmptyString
  donor2Name: NonEmptyString
  donor2Pm: NonEmptyString
  donor2Relation: NonEmptyString
  donor2TitleBar: NonEmptyString
  effectiveDate: LocalDate
  gikDescription: NonEmptyString
  gikType: NonEmptyString
  hcUnit: NonEmptyString
  holdingDestination: NonEmptyString
  idSorter: NonEmptyString!
  jvDocDate: LocalDate
  jvDocNum: NonEmptyString
  matchingGift: NonEmptyString
  onlineGift: Boolean!
  pledgedAmount: Float!
  pledgedDate: LocalDate
  processDate: LocalDate!
  sapDocDate: LocalDate
  sapDocNum: NonEmptyString
  secShares: NonEmptyString
  secType: NonEmptyString
  solicitation: NonEmptyString
  solicitationCode: NonEmptyString!
  transactionDate: LocalDate
  transactionType: NonEmptyString!
  transmittalSn: NonEmptyString
  ukFirstGift: Boolean!
}

type DailyDepartmentNotificationNode {
  accountName: String!
  accountNumber: String!
  advFeeAmtPhil: Float
  advFeeAmtUnit: Float
  advFeeCcPhil: String
  advFeeCcUnit: String
  advFeeStatus: String
  batch: DailyDepartmentNotificationBatchNode!
  behalfHonorMemorial: String
  combinedAmount: Float!
  combinedDonorName: String!
  combinedDonorSalutation: String!
  combinedDonorSort: String
  comment: String
  department: String
  divFirstGift: Boolean!
  division: String
  donor1Amount: Float
  donor1Constituency: String
  donor1Deceased: Boolean
  donor1Degrees: String
  donor1GiftKey: String
  donor1Id: String
  donor1Name: String
  donor1Pm: String
  donor1Relation: String
  donor1TitleBar: String
  donor2Amount: Float
  donor2Constituency: String
  donor2Deceased: Boolean
  donor2Degrees: String
  donor2GiftKey: String
  donor2Id: String
  donor2Name: String
  donor2Pm: String
  donor2Relation: String
  donor2TitleBar: String
  effectiveDate: LocalDate
  gikDescription: String
  gikType: String
  hcUnit: String
  holdingDestination: String
  id: GlobalId!
  idSorter: String!
  jvDocDate: LocalDate
  jvDocNum: String
  matchingGift: String
  onlineGift: Boolean!
  pledgedAmount: Float!
  pledgedDate: LocalDate
  processDate: LocalDate
  sapDocDate: LocalDate
  sapDocNum: String
  secShares: String
  secType: String
  solicitation: String
  solicitationCode: SolicitationCodeNode!
  transactionDate: LocalDate
  transactionType: String!
  transmittalSn: String
  ukFirstGift: Boolean!
}

enum DailyDepartmentNotificationResolverAllKeys {
  Amount
  BatchType
  Comment
  Donor
  SolicitationCodeName
  SolicitationCodeNumber
  SolicitationCodePrefix
}

input DailyDepartmentNotificationResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: DailyDepartmentNotificationResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input DailyDepartmentNotificationResolverKeyedNumericFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: DailyDepartmentNotificationResolverNumericFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: Float!
}

input DailyDepartmentNotificationResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: DailyDepartmentNotificationResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input DailyDepartmentNotificationResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: DailyDepartmentNotificationResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum DailyDepartmentNotificationResolverNumericFilterKeys {
  Amount
}

enum DailyDepartmentNotificationResolverOneOfFilterKeys {
  BatchType
  SolicitationCodeNumber
  SolicitationCodePrefix
}

enum DailyDepartmentNotificationResolverStringFilterKeys {
  Comment
  Donor
  SolicitationCodeName
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

type DbFundsTeamInfo {
  dbNum: Int!
  name: String!
}

"""DanceBlue roles"""
enum DbRole {
  Committee
  None
  Public
  UKY
}

type DeviceNode implements Node {
  createdAt: DateTimeISO
  id: GlobalId!
  lastLoggedInUser: PersonNode
  lastLogin: DateTimeISO

  """List all notification deliveries for this device"""
  notificationDeliveries(
    page: Int = 1
    pageSize: Int = 10

    """
    The verifier code for this device, if it does not match then the query will be rejected
    """
    verifier: String
  ): [NotificationDeliveryNode!]!
  updatedAt: DateTimeISO
}

enum DeviceResolverAllKeys {
  createdAt
  expoPushToken
  lastSeen
  updatedAt
}

enum DeviceResolverDateFilterKeys {
  createdAt
  lastSeen
  updatedAt
}

input DeviceResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: DeviceResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input DeviceResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: DeviceResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input DeviceResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: Void!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input DeviceResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: DeviceResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum DeviceResolverStringFilterKeys {
  expoPushToken
}

type EffectiveCommitteeRole {
  identifier: CommitteeIdentifier!
  role: CommitteeRole!
}

"""
A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address.
"""
scalar EmailAddress @specifiedBy(url: "https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address")

type EventNode implements Node {
  createdAt: DateTimeISO
  description: String
  id: GlobalId!

  """List all images for this event"""
  images: [ImageNode!]!
  location: String
  occurrences: [EventOccurrenceNode!]!
  summary: String
  title: String!
  updatedAt: DateTimeISO
}

type EventOccurrenceNode {
  fullDay: Boolean!
  id: ID!
  interval: IntervalISO!
}

enum EventResolverAllKeys {
  createdAt
  description
  location
  occurrence
  occurrenceEnd
  occurrenceStart
  summary
  title
  updatedAt
}

enum EventResolverDateFilterKeys {
  createdAt
  occurrence
  occurrenceEnd
  occurrenceStart
  updatedAt
}

input EventResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: EventResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input EventResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: EventResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input EventResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: Void!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input EventResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: EventResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum EventResolverStringFilterKeys {
  description
  location
  summary
  title
}

type FeedNode implements Node {
  createdAt: DateTimeISO
  id: GlobalId!

  """The image associated with this feed item"""
  image: ImageNode
  textContent: String
  title: String!
  updatedAt: DateTimeISO
}

type FundraisingAssignmentNode implements Node {
  amount: Float!
  createdAt: DateTimeISO
  entry: FundraisingEntryNode!
  id: GlobalId!

  """
  The person assigned to this assignment, only null when access is denied
  """
  person: PersonNode
  updatedAt: DateTimeISO
}

type FundraisingEntryNode implements Node {
  amount: Float!
  amountOverride: Float
  amountUnassigned: Float!
  assignments: [FundraisingAssignmentNode!]!
  batchType: BatchType!
  batchTypeOverride: BatchType
  createdAt: DateTimeISO
  dailyDepartmentNotification: DailyDepartmentNotificationNode
  donatedByOverride: String
  donatedByText: String
  donatedOn: DateTimeISO!
  donatedOnOverride: DateTimeISO
  donatedToOverride: String
  donatedToText: String
  id: GlobalId!
  notes: String
  solicitationCode: SolicitationCodeNode!
  solicitationCodeOverride: SolicitationCodeNode
  updatedAt: DateTimeISO
}

enum FundraisingEntryResolverAllKeys {
  amount
  amountUnassigned
  batchType
  createdAt
  donatedBy
  donatedOn
  donatedTo
  solicitationCode
  teamId
  updatedAt
}

enum FundraisingEntryResolverDateFilterKeys {
  createdAt
  donatedOn
  updatedAt
}

input FundraisingEntryResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: FundraisingEntryResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input FundraisingEntryResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: FundraisingEntryResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input FundraisingEntryResolverKeyedNumericFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: FundraisingEntryResolverNumericFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: Float!
}

input FundraisingEntryResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: FundraisingEntryResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input FundraisingEntryResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: FundraisingEntryResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum FundraisingEntryResolverNumericFilterKeys {
  amount
  amountUnassigned
}

enum FundraisingEntryResolverOneOfFilterKeys {
  batchType
  teamId
}

enum FundraisingEntryResolverStringFilterKeys {
  donatedBy
  donatedTo
  solicitationCode
}

type GetConfigurationByUuidResponse {
  data: ConfigurationNode!
}

type GetDeviceByUuidResponse {
  data: DeviceNode!
}

"""GlobalId custom scalar type"""
scalar GlobalId

type ImageNode implements Node {
  alt: String
  createdAt: DateTimeISO
  height: Int!
  id: GlobalId!
  mimeType: String!
  thumbHash: String
  updatedAt: DateTimeISO
  url: URL
  width: Int!
}

enum ImageResolverAllKeys {
  alt
  createdAt
  height
  updatedAt
  width
}

enum ImageResolverDateFilterKeys {
  createdAt
  updatedAt
}

input ImageResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: ImageResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input ImageResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: ImageResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input ImageResolverKeyedNumericFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: ImageResolverNumericFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: Float!
}

input ImageResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: Void!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input ImageResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: ImageResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum ImageResolverNumericFilterKeys {
  height
  width
}

enum ImageResolverStringFilterKeys {
  alt
}

type IntervalISO {
  end: DateTimeISO!
  start: DateTimeISO!
}

input IntervalISOInput {
  end: DateTimeISO!
  start: DateTimeISO!
}

type ListDailyDepartmentNotificationsResponse implements AbstractGraphQLPaginatedResponse {
  data: [DailyDepartmentNotificationNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListDevicesResponse implements AbstractGraphQLPaginatedResponse {
  data: [DeviceNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListEventsResponse implements AbstractGraphQLPaginatedResponse {
  data: [EventNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListFundraisingEntriesResponse implements AbstractGraphQLPaginatedResponse {
  data: [FundraisingEntryNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListImagesResponse implements AbstractGraphQLPaginatedResponse {
  data: [ImageNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListMarathonHoursResponse implements AbstractGraphQLPaginatedResponse {
  data: [MarathonHourNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListMarathonsResponse implements AbstractGraphQLPaginatedResponse {
  data: [MarathonNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListNotificationDeliveriesResponse implements AbstractGraphQLPaginatedResponse {
  data: [NotificationDeliveryNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListNotificationsResponse implements AbstractGraphQLPaginatedResponse {
  data: [NotificationNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPeopleResponse implements AbstractGraphQLPaginatedResponse {
  data: [PersonNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPointEntriesResponse implements AbstractGraphQLPaginatedResponse {
  data: [PointEntryNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPointOpportunitiesResponse implements AbstractGraphQLPaginatedResponse {
  data: [PointOpportunityNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListTeamsResponse implements AbstractGraphQLPaginatedResponse {
  data: [TeamNode!]!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

"""
A local date string (i.e., with no associated timezone) in `YYYY-MM-DD` format, e.g. `2020-01-01`.
"""
scalar LocalDate

type LoginState {
  accessLevel: AccessLevel!
  authSource: AuthSource!
  dbRole: DbRole!
  effectiveCommitteeRoles: [EffectiveCommitteeRole!]!
  loggedIn: Boolean!
}

type MarathonHourNode implements Node {
  createdAt: DateTimeISO
  details: String
  durationInfo: String!
  id: GlobalId!
  mapImages: [ImageNode!]!
  shownStartingAt: DateTimeISO!
  title: String!
  updatedAt: DateTimeISO
}

enum MarathonHourResolverAllKeys {
  createdAt
  details
  durationInfo
  marathonYear
  shownStartingAt
  title
  updatedAt
}

enum MarathonHourResolverDateFilterKeys {
  createdAt
  shownStartingAt
  updatedAt
}

input MarathonHourResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: MarathonHourResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input MarathonHourResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: MarathonHourResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input MarathonHourResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: MarathonHourResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input MarathonHourResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: MarathonHourResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum MarathonHourResolverOneOfFilterKeys {
  marathonYear
}

enum MarathonHourResolverStringFilterKeys {
  details
  durationInfo
  title
}

type MarathonNode implements Node {
  communityDevelopmentCommitteeTeam: TeamNode!
  corporateCommitteeTeam: TeamNode!
  createdAt: DateTimeISO
  dancerRelationsCommitteeTeam: TeamNode!
  endDate: DateTimeISO
  familyRelationsCommitteeTeam: TeamNode!
  fundraisingCommitteeTeam: TeamNode!
  hours: [MarathonHourNode!]!
  id: GlobalId!
  marketingCommitteeTeam: TeamNode!
  miniMarathonsCommitteeTeam: TeamNode!
  operationsCommitteeTeam: TeamNode!
  overallCommitteeTeam: TeamNode!
  programmingCommitteeTeam: TeamNode!
  startDate: DateTimeISO
  techCommitteeTeam: TeamNode!
  updatedAt: DateTimeISO
  viceCommitteeTeam: TeamNode!
  year: String!
}

enum MarathonResolverAllKeys {
  createdAt
  endDate
  startDate
  updatedAt
  year
}

enum MarathonResolverDateFilterKeys {
  createdAt
  endDate
  startDate
  updatedAt
}

input MarathonResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: MarathonResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input MarathonResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: MarathonResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input MemberOf {
  committeeRole: CommitteeRole
  id: GlobalId!
}

type MembershipNode implements Node {
  committeeRole: CommitteeRole
  createdAt: DateTimeISO
  id: GlobalId!
  person: PersonNode!
  position: MembershipPositionType!
  team: TeamNode!
  updatedAt: DateTimeISO
}

"""The position of a member on a team"""
enum MembershipPositionType {
  Captain
  Member
}

type Mutation {
  abortScheduledNotification(uuid: GlobalId!): NotificationNode!
  acknowledgeDeliveryIssue(uuid: GlobalId!): NotificationNode!

  """Add an existing image to an event"""
  addExistingImageToEvent(eventId: GlobalId!, imageId: GlobalId!): ImageNode!
  addMap(imageUuid: GlobalId!, uuid: GlobalId!): MarathonHourNode!
  addPersonToTeam(personUuid: GlobalId!, position: MembershipPositionType! = Member, teamUuid: GlobalId!): MembershipNode!
  assignEntryToPerson(entryId: GlobalId!, input: AssignEntryToPersonInput!, personId: GlobalId!): FundraisingAssignmentNode!
  assignSolicitationCodeToTeam(solicitationCode: GlobalId!, teamId: GlobalId!): Void!

  """Attach an image to a feed item"""
  attachImageToFeedItem(feedItemUuid: GlobalId!, imageUuid: GlobalId!): FeedNode!
  batchUploadDailyDepartmentNotifications(input: [DailyDepartmentNotificationInput!]!): [DailyDepartmentNotificationNode!]!
  bulkLoadPeople(marathonId: GlobalId!, people: [BulkPersonInput!]!): [PersonNode!]!

  """
  Create a new configuration, superseding existing configurations with the same key (depending on the validAfter and validUntil fields)
  """
  createConfiguration(input: CreateConfigurationInput!): ConfigurationNode!

  """
  Create multiple configurations, superseding existing configurations with the same key (depending on the validAfter and validUntil fields)
  """
  createConfigurations(input: [CreateConfigurationInput!]!): [ConfigurationNode!]!
  createDailyDepartmentNotification(input: DailyDepartmentNotificationInput!): DailyDepartmentNotificationNode!

  """Create a new event"""
  createEvent(input: CreateEventInput!): EventNode!

  """Add a new item to the feed"""
  createFeedItem(input: CreateFeedInput!): FeedNode!
  createImage(input: CreateImageInput!): ImageNode!
  createMarathon(input: CreateMarathonInput!): MarathonNode!
  createMarathonHour(input: CreateMarathonHourInput!, marathonUuid: GlobalId!): MarathonHourNode!
  createPerson(input: CreatePersonInput!): PersonNode!
  createPointEntry(input: CreatePointEntryInput!): PointEntryNode!
  createPointOpportunity(input: CreatePointOpportunityInput!): PointOpportunityNode!
  createTeam(input: CreateTeamInput!, marathon: GlobalId!): TeamNode!
  createTeams(marathonId: GlobalId!, teams: [BulkTeamInput!]!): [TeamNode!]!

  """Delete a configuration by UUID"""
  deleteConfiguration(uuid: GlobalId!): ConfigurationNode!
  deleteDailyDepartmentNotification(id: GlobalId!): DailyDepartmentNotificationNode!
  deleteDailyDepartmentNotificationBatch(id: GlobalId!): DailyDepartmentNotificationBatchNode!

  """Delete a device by it's UUID"""
  deleteDevice(uuid: GlobalId!): DeviceNode!

  """Delete an event by UUID"""
  deleteEvent(uuid: GlobalId!): EventNode!

  """Delete a feed item"""
  deleteFeedItem(feedItemUuid: GlobalId!): Boolean!
  deleteFundraisingAssignment(id: GlobalId!): FundraisingAssignmentNode!
  deleteImage(uuid: GlobalId!): ImageNode!
  deleteMarathon(uuid: GlobalId!): MarathonNode!
  deleteMarathonHour(uuid: GlobalId!): Void!
  deleteNotification(
    """
    If true, the notification will be deleted even if it has already been sent, which will also delete the delivery records.
    """
    force: Boolean
    uuid: GlobalId!
  ): NotificationNode!
  deletePerson(uuid: GlobalId!): PersonNode!
  deletePointEntry(uuid: GlobalId!): PointEntryNode!
  deletePointOpportunity(uuid: GlobalId!): PointOpportunityNode!
  deleteTeam(uuid: GlobalId!): TeamNode!

  """Register a new device, or update an existing one"""
  registerDevice(input: RegisterDeviceInput!): RegisterDeviceResponse!

  """Remove an image from an event"""
  removeImageFromEvent(eventId: GlobalId!, imageId: GlobalId!): Void!

  """Remove an image from a feed item"""
  removeImageFromFeedItem(feedItemUuid: GlobalId!): FeedNode!
  removeMap(imageUuid: GlobalId!, uuid: GlobalId!): Void!
  removePersonFromTeam(personUuid: GlobalId!, teamUuid: GlobalId!): MembershipNode!
  removeSolicitationCodeFromTeam(teamId: GlobalId!): Void!
  scheduleNotification(sendAt: DateTimeISO!, uuid: GlobalId!): NotificationNode!

  """Send a notification immediately."""
  sendNotification(uuid: GlobalId!): Void!
  setDailyDepartmentNotification(id: GlobalId!, input: DailyDepartmentNotificationInput!): DailyDepartmentNotificationNode!

  """Update an event by UUID"""
  setEvent(input: SetEventInput!, uuid: GlobalId!): EventNode!

  """Set the content of a feed item"""
  setFeedItem(feedItemUuid: GlobalId!, input: SetFeedInput!): FeedNode!
  setFundraisingEntry(id: GlobalId!, input: SetFundraisingEntryInput!): FundraisingEntryNode!
  setImageAltText(alt: String!, uuid: GlobalId!): ImageNode!
  setImageUrl(url: URL!, uuid: GlobalId!): ImageNode!
  setMarathon(input: SetMarathonInput!, uuid: GlobalId!): MarathonNode!
  setMarathonHour(input: SetMarathonHourInput!, uuid: GlobalId!): MarathonHourNode!
  setPerson(input: SetPersonInput!, uuid: GlobalId!): PersonNode!
  setPointOpportunity(input: SetPointOpportunityInput!, uuid: GlobalId!): PointOpportunityNode!
  setTeam(input: SetTeamInput!, uuid: GlobalId!): TeamNode!
  stageNotification(audience: NotificationAudienceInput!, body: NonEmptyString!, title: NonEmptyString!, url: URL): NotificationNode!
  updateFundraisingAssignment(id: GlobalId!, input: UpdateFundraisingAssignmentInput!): FundraisingAssignmentNode!
}

interface Node {
  id: GlobalId!
}

"""A string that cannot be passed as an empty value"""
scalar NonEmptyString

"""Integers that will have a value of 0 or more."""
scalar NonNegativeInt

input NotificationAudienceInput {
  all: Boolean
  memberOfTeamType: TeamType
  memberOfTeams: [GlobalId!]
  users: [GlobalId!]
}

"""The number of delivery issues for a notification, broken down by type."""
type NotificationDeliveryIssueCount {
  DeviceNotRegistered: Int!
  InvalidCredentials: Int!
  MessageRateExceeded: Int!
  MessageTooBig: Int!
  MismatchSenderId: Int!
  Unknown: Int!
}

type NotificationDeliveryNode implements Node {
  """
  A unique identifier corresponding the group of notifications this was sent to Expo with.
  """
  chunkUuid: String
  createdAt: DateTimeISO

  """Any error message returned by Expo when sending the notification."""
  deliveryError: String
  id: GlobalId!
  notification: NotificationNode!

  """The time the server received a delivery receipt from the user."""
  receiptCheckedAt: DateTimeISO

  """The time the server sent the notification to Expo for delivery."""
  sentAt: DateTimeISO
  updatedAt: DateTimeISO
}

enum NotificationDeliveryResolverAllKeys {
  createdAt
  deliveryError
  receiptCheckedAt
  sentAt
  updatedAt
}

enum NotificationDeliveryResolverDateFilterKeys {
  createdAt
  receiptCheckedAt
  sentAt
  updatedAt
}

input NotificationDeliveryResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: NotificationDeliveryResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input NotificationDeliveryResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: NotificationDeliveryResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

type NotificationNode implements Node {
  body: String!
  createdAt: DateTimeISO
  deliveryCount: Int!
  deliveryIssue: String
  deliveryIssueAcknowledgedAt: DateTimeISO
  deliveryIssueCount: NotificationDeliveryIssueCount!
  id: GlobalId!

  """
  The time the notification is scheduled to be sent, if null it is either already sent or unscheduled.
  """
  sendAt: DateTimeISO

  """The time the server started sending the notification."""
  startedSendingAt: DateTimeISO
  title: String!
  updatedAt: DateTimeISO
  url: URL
}

enum NotificationResolverAllKeys {
  body
  createdAt
  deliveryIssue
  sendAt
  startedSendingAt
  title
  updatedAt
}

enum NotificationResolverDateFilterKeys {
  createdAt
  sendAt
  startedSendingAt
  updatedAt
}

input NotificationResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: NotificationResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input NotificationResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: NotificationResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input NotificationResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: NotificationResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input NotificationResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: NotificationResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum NotificationResolverOneOfFilterKeys {
  deliveryIssue
}

enum NotificationResolverStringFilterKeys {
  body
  title
}

enum NumericComparator {
  EQUALS
  GREATER_THAN
  GREATER_THAN_OR_EQUAL_TO
  IS
  LESS_THAN
  LESS_THAN_OR_EQUAL_TO
}

type PersonNode implements Node {
  assignedDonationEntries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [FundraisingEntryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [FundraisingEntryResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [FundraisingEntryResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [FundraisingEntryResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [FundraisingEntryResolverKeyedStringFilterItem!]
  ): ListFundraisingEntriesResponse
  committees: [CommitteeMembershipNode!]!
  createdAt: DateTimeISO
  dbRole: DbRole!
  email: String!
  fundraisingAssignments: [FundraisingAssignmentNode!]!
  fundraisingTotalAmount: Float
  id: GlobalId!
  linkblue: String
  moraleTeams: [MembershipNode!]!
  name: String
  primaryCommittee: CommitteeMembershipNode
  primaryTeam(teamType: TeamType!): MembershipNode
  teams: [MembershipNode!]!
  updatedAt: DateTimeISO
}

enum PersonResolverAllKeys {
  committeeName
  committeeRole
  dbRole
  email
  linkblue
  name
}

input PersonResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PersonResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input PersonResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: PersonResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input PersonResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: PersonResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum PersonResolverOneOfFilterKeys {
  committeeName
  committeeRole
  dbRole
}

enum PersonResolverStringFilterKeys {
  email
  linkblue
  name
}

type PointEntryNode implements Node {
  comment: String
  createdAt: DateTimeISO
  id: GlobalId!
  personFrom: PersonNode
  pointOpportunity: PointOpportunityNode
  points: Int!
  team: TeamNode!
  updatedAt: DateTimeISO
}

enum PointEntryResolverAllKeys {
  createdAt
  updatedAt
}

enum PointEntryResolverDateFilterKeys {
  createdAt
  updatedAt
}

input PointEntryResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: PointEntryResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input PointEntryResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PointEntryResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

type PointOpportunityNode implements Node {
  createdAt: DateTimeISO
  event: EventNode
  id: GlobalId!
  name: String!
  opportunityDate: DateTimeISO
  type: TeamType!
  updatedAt: DateTimeISO
}

enum PointOpportunityResolverAllKeys {
  createdAt
  marathonUuid
  name
  opportunityDate
  type
  updatedAt
}

enum PointOpportunityResolverDateFilterKeys {
  createdAt
  opportunityDate
  updatedAt
}

input PointOpportunityResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: PointOpportunityResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input PointOpportunityResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PointOpportunityResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input PointOpportunityResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: PointOpportunityResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input PointOpportunityResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: PointOpportunityResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum PointOpportunityResolverOneOfFilterKeys {
  marathonUuid
  type
}

enum PointOpportunityResolverStringFilterKeys {
  name
}

"""Integers that will have a value greater than 0."""
scalar PositiveInt

type Query {
  """Get the active configuration for a given key at the current time"""
  activeConfiguration(key: String!): GetConfigurationByUuidResponse!

  """Get all configurations, irrespective of time"""
  allConfigurations: [ConfigurationNode!]!

  """Get the audit log file from the server"""
  auditLog(lines: Float! = 25, offset: Float! = 0): String!

  """Get a particular configuration entry by UUID"""
  configuration(id: GlobalId!): ConfigurationNode!

  """
  The marathon that is currently happening, i.e. the marathon with the latest start date that has not yet ended.
  """
  currentMarathon: MarathonNode
  currentMarathonHour: MarathonHourNode
  dailyDepartmentNotification(id: GlobalId!): DailyDepartmentNotificationNode!
  dailyDepartmentNotificationBatch(id: GlobalId!): DailyDepartmentNotificationBatchNode!
  dailyDepartmentNotifications(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: Void

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [DailyDepartmentNotificationResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [DailyDepartmentNotificationResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [DailyDepartmentNotificationResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [DailyDepartmentNotificationResolverKeyedStringFilterItem!]
  ): ListDailyDepartmentNotificationsResponse!
  dbFundsTeams(search: String!): [DbFundsTeamInfo!]!

  """Get a device by it's UUID"""
  device(
    """For legacy reasons, this can be a GlobalId or a raw UUID"""
    uuid: String!
  ): GetDeviceByUuidResponse!

  """List all devices"""
  devices(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [DeviceResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [DeviceResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [DeviceResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [DeviceResolverKeyedStringFilterItem!]
  ): ListDevicesResponse!

  """Get an event by UUID"""
  event(uuid: GlobalId!): EventNode!

  """List events"""
  events(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [EventResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [EventResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [EventResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [EventResolverKeyedStringFilterItem!]
  ): ListEventsResponse!

  """Get the active feed"""
  feed(limit: Int = 10): [FeedNode!]!

  """Get a feed item by its UUID"""
  feedItem(feedItemId: GlobalId!): FeedNode!
  fundraisingAssignment(id: GlobalId!): FundraisingAssignmentNode!
  fundraisingEntries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [FundraisingEntryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [FundraisingEntryResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [FundraisingEntryResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [FundraisingEntryResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [FundraisingEntryResolverKeyedStringFilterItem!]
  ): ListFundraisingEntriesResponse!
  fundraisingEntry(id: GlobalId!): FundraisingEntryNode!
  image(uuid: GlobalId!): ImageNode!
  images(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [ImageResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [ImageResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [ImageResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [ImageResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [ImageResolverKeyedStringFilterItem!]
  ): ListImagesResponse!

  """
  The most recent marathon, regardless of whether it is currently happening, i.e. the marathon with the latest year.
  """
  latestMarathon: MarathonNode
  listPeople(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: Void

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [PersonResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [PersonResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [PersonResolverKeyedStringFilterItem!]
  ): ListPeopleResponse!
  loginState: LoginState!
  marathon(uuid: GlobalId!): MarathonNode!
  marathonForYear(year: String!): MarathonNode!
  marathonHour(uuid: GlobalId!): MarathonHourNode!
  marathonHours(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [MarathonHourResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [MarathonHourResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [MarathonHourResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [MarathonHourResolverKeyedStringFilterItem!]
  ): ListMarathonHoursResponse!
  marathons(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [MarathonResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [MarathonResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: Void

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: Void
  ): ListMarathonsResponse!
  me: PersonNode
  node(id: GlobalId!): Node!
  notification(uuid: GlobalId!): NotificationNode!
  notificationDeliveries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [NotificationDeliveryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [NotificationDeliveryResolverKeyedIsNullFilterItem!]
    notificationUuid: GlobalId!

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: Void

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: Void
  ): ListNotificationDeliveriesResponse!
  notifications(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [NotificationResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [NotificationResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [NotificationResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [NotificationResolverKeyedStringFilterItem!]
  ): ListNotificationsResponse!
  person(uuid: GlobalId!): PersonNode!
  personByLinkBlue(linkBlueId: String!): PersonNode
  pointEntries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [PointEntryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [PointEntryResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: Void

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: Void
  ): ListPointEntriesResponse!
  pointEntry(uuid: GlobalId!): PointEntryNode!
  pointOpportunities(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [PointOpportunityResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [PointOpportunityResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [PointOpportunityResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [PointOpportunityResolverKeyedStringFilterItem!]
  ): ListPointOpportunitiesResponse!
  pointOpportunity(uuid: GlobalId!): PointOpportunityNode!
  rawFundraisingEntries(identifier: Int!, marathonYear: String!): String!
  rawFundraisingTotals(marathonYear: String!): String!

  """
  The output of this query is not stable. Do not rely on an exact format.
  """
  report(from: DateTimeISO, report: NonEmptyString!, to: DateTimeISO): Report!
  searchPeopleByName(name: String!): [PersonNode!]!
  solicitationCode(id: GlobalId!): SolicitationCodeNode!
  solicitationCodes: [SolicitationCodeNode!]!
  team(uuid: GlobalId!): TeamNode!
  teams(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: Void

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [TeamResolverKeyedIsNullFilterItem!]
    legacyStatus: [TeamLegacyStatus!]
    marathonId: [GlobalId!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [TeamResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [TeamResolverKeyedStringFilterItem!]
    type: [TeamType!]
    visibility: [DbRole!] @deprecated(reason: "Use type")
  ): ListTeamsResponse!
}

input RegisterDeviceInput {
  """For legacy reasons, this can be a GlobalId or a raw UUID"""
  deviceId: String!

  """The Expo push token of the device"""
  expoPushToken: String

  """The ID of the last user to log in on this device"""
  lastUserId: GlobalId

  """base64 encoded SHA-256 hash of a secret known to the device"""
  verifier: String!
}

type RegisterDeviceResponse {
  data: DeviceNode!
  ok: Boolean!
}

type Report {
  pages: [ReportPage!]!
}

type ReportPage {
  header: [String!]!
  rows: [[String!]!]!
  title: NonEmptyString!
}

input SetEventInput {
  description: NonEmptyString
  location: NonEmptyString
  occurrences: [SetEventOccurrenceInput!]!
  summary: NonEmptyString
  title: String!
}

input SetEventOccurrenceInput {
  fullDay: Boolean!
  interval: IntervalISOInput!

  """
  If updating an existing occurrence, the UUID of the occurrence to update
  """
  uuid: GlobalId
}

input SetFeedInput {
  textContent: NonEmptyString
  title: NonEmptyString!
}

input SetFundraisingEntryInput {
  amountOverride: Float
  batchTypeOverride: BatchType
  donatedByOverride: NonEmptyString
  donatedOnOverride: NonEmptyString
  donatedToOverride: NonEmptyString
  notes: NonEmptyString
  solicitationCodeOverrideId: GlobalId
}

input SetMarathonHourInput {
  details: NonEmptyString
  durationInfo: NonEmptyString!
  shownStartingAt: DateTimeISO!
  title: NonEmptyString!
}

input SetMarathonInput {
  endDate: DateTimeISO
  startDate: DateTimeISO
  year: NonEmptyString!
}

input SetPersonInput {
  captainOf: [MemberOf!]
  email: EmailAddress
  linkblue: NonEmptyString
  memberOf: [MemberOf!]
  name: NonEmptyString
}

input SetPointOpportunityInput {
  eventUuid: GlobalId
  name: NonEmptyString
  opportunityDate: DateTimeISO
  type: TeamType
}

input SetTeamInput {
  legacyStatus: TeamLegacyStatus
  name: NonEmptyString
  persistentIdentifier: NonEmptyString
  type: TeamType
}

type SolicitationCodeNode implements Node {
  code: NonNegativeInt!
  createdAt: DateTimeISO
  entries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [FundraisingEntryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [FundraisingEntryResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [FundraisingEntryResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [FundraisingEntryResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [FundraisingEntryResolverKeyedStringFilterItem!]
  ): ListFundraisingEntriesResponse!
  id: GlobalId!
  name: String
  prefix: String!
  teams(marathonId: GlobalId): [TeamNode!]!
  text: String!
  updatedAt: DateTimeISO
}

enum SortDirection {
  asc
  desc
}

enum StringComparator {
  ENDS_WITH
  EQUALS
  IS
  STARTS_WITH
  SUBSTRING
}

"""New Team vs Returning Team"""
enum TeamLegacyStatus {
  DemoTeam
  NewTeam
  ReturningTeam
}

type TeamNode implements Node {
  captains: [MembershipNode!]! @deprecated(reason: "Just query the members field and filter by role")
  committeeIdentifier: CommitteeIdentifier
  createdAt: DateTimeISO
  dbFundsTeam: DbFundsTeamInfo
  fundraisingEntries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [FundraisingEntryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [FundraisingEntryResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [FundraisingEntryResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [FundraisingEntryResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean = false

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [FundraisingEntryResolverKeyedStringFilterItem!]
  ): ListFundraisingEntriesResponse!
  fundraisingTotalAmount: Float
  id: GlobalId!
  legacyStatus: TeamLegacyStatus!
  marathon: MarathonNode!
  members: [MembershipNode!]!
  name: String!
  pointEntries: [PointEntryNode!]!
  solicitationCode: SolicitationCodeNode
  totalPoints: Int!
  type: TeamType!
  updatedAt: DateTimeISO
}

enum TeamResolverAllKeys {
  legacyStatus
  marathonId
  name
  type
}

input TeamResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: TeamResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input TeamResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: TeamResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input TeamResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: TeamResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum TeamResolverOneOfFilterKeys {
  legacyStatus
  marathonId
  type
}

enum TeamResolverStringFilterKeys {
  name
}

"""Types of teams"""
enum TeamType {
  Morale
  Spirit
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

input UpdateFundraisingAssignmentInput {
  amount: Float!
}

"""Represents NULL values"""
scalar Void