# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AbortScheduledNotificationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

"""API response"""
interface AbstractGraphQLArrayOkResponse implements GraphQLBaseResponse {
  ok: Boolean!
}

"""API response"""
interface AbstractGraphQLCreatedResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
  uuid: GlobalId!
}

"""API response"""
interface AbstractGraphQLOkResponse implements GraphQLBaseResponse {
  ok: Boolean!
}

"""API response"""
interface AbstractGraphQLPaginatedResponse implements AbstractGraphQLArrayOkResponse & GraphQLBaseResponse {
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

"""The level of access a user has"""
enum AccessLevel {
  Admin
  Committee
  CommitteeChairOrCoordinator
  None
  Public
  SuperAdmin
  UKY
}

type AcknowledgeDeliveryIssueResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

type AddEventImageResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ImageNode!
  ok: Boolean!
}

input AssignEntryToPersonInput {
  amount: Float!
}

"""The source of authentication"""
enum AuthSource {
  Anonymous
  Demo
  LinkBlue
  None
}

input BulkPersonInput {
  committee: CommitteeIdentifier
  email: EmailAddress!
  linkblue: String!
  name: String!
  role: CommitteeRole
}

input BulkTeamInput {
  captainLinkblues: [String!]
  legacyStatus: TeamLegacyStatus!
  memberLinkblues: [String!]
  name: String!
  type: TeamType!
}

"""The identifier for a committee"""
enum CommitteeIdentifier {
  communityDevelopmentCommittee
  corporateCommittee
  dancerRelationsCommittee
  familyRelationsCommittee
  fundraisingCommittee
  marketingCommittee
  miniMarathonsCommittee
  operationsCommittee
  overallCommittee
  programmingCommittee
  techCommittee
  viceCommittee
}

type CommitteeMembershipNode implements Node {
  committeeRole: CommitteeRole
  createdAt: DateTimeISO
  id: GlobalId!
  identifier: CommitteeIdentifier!
  person: PersonNode!
  position: MembershipPositionType!
  role: CommitteeRole!
  team: TeamNode!
  updatedAt: DateTimeISO
}

type CommitteeNode implements Node {
  createdAt: DateTimeISO
  id: GlobalId!
  identifier: CommitteeIdentifier!
  updatedAt: DateTimeISO
}

"""Roles within a committee"""
enum CommitteeRole {
  Chair
  Coordinator
  Member
}

type ConfigurationNode implements Node {
  createdAt: DateTimeISO
  id: GlobalId!
  key: String!
  updatedAt: DateTimeISO
  validAfter: DateTimeISO
  validUntil: DateTimeISO
  value: String!
}

input CreateConfigurationInput {
  key: String!
  validAfter: DateTimeISO
  validUntil: DateTimeISO
  value: String!
}

type CreateConfigurationResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ConfigurationNode!
  ok: Boolean!
  uuid: GlobalId!
}

input CreateEventInput {
  description: String
  location: String
  occurrences: [CreateEventOccurrenceInput!]!
  summary: String
  title: String!
}

input CreateEventOccurrenceInput {
  fullDay: Boolean!
  interval: IntervalISOInput!
}

type CreateEventResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: EventNode!
  ok: Boolean!
  uuid: GlobalId!
}

input CreateFeedInput {
  imageUuid: String
  textContent: String
  title: String!
}

input CreateImageInput {
  alt: String
  url: URL
}

input CreateMarathonHourInput {
  details: String
  durationInfo: String!
  shownStartingAt: DateTimeISO!
  title: String!
}

input CreateMarathonInput {
  endDate: DateTimeISO
  startDate: DateTimeISO
  year: String!
}

input CreatePersonInput {
  captainOf: [MemberOf!]! = []
  dbRole: DbRole @deprecated(reason: "DBRole can no longer be set directly")
  email: EmailAddress!
  linkblue: String
  memberOf: [MemberOf!]! = []
  name: String
}

input CreatePointEntryInput {
  comment: String
  opportunityUuid: GlobalId
  personFromUuid: GlobalId
  points: Int!
  teamUuid: GlobalId!
}

type CreatePointEntryResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointEntryNode!
  ok: Boolean!
  uuid: GlobalId!
}

input CreatePointOpportunityInput {
  eventUuid: GlobalId
  marathonUuid: GlobalId!
  name: String!
  opportunityDate: DateTimeISO
  type: TeamType!
}

type CreatePointOpportunityResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointOpportunityNode!
  ok: Boolean!
  uuid: GlobalId!
}

input CreateTeamInput {
  legacyStatus: TeamLegacyStatus!
  name: String!
  type: TeamType!
}

type CreateTeamResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: TeamNode!
  ok: Boolean!
  uuid: GlobalId!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

type DbFundsTeamInfo {
  dbNum: Int!
  name: String!
}

"""DanceBlue roles"""
enum DbRole {
  Committee
  None
  Public
  UKY
}

type DeleteConfigurationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteDeviceResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteEventResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteImageResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteNotificationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

type DeletePointEntryResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeletePointOpportunityResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteTeamResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeviceNode implements Node {
  createdAt: DateTimeISO
  id: GlobalId!
  lastLoggedInUser: PersonNode
  lastLogin: DateTimeISO

  """List all notification deliveries for this device"""
  notificationDeliveries(
    page: Int = 1
    pageSize: Int = 10

    """
    The verifier code for this device, if it does not match then the query will be rejected
    """
    verifier: String
  ): [NotificationDeliveryNode!]!
  updatedAt: DateTimeISO
}

enum DeviceResolverAllKeys {
  createdAt
  expoPushToken
  lastSeen
  updatedAt
}

enum DeviceResolverDateFilterKeys {
  createdAt
  lastSeen
  updatedAt
}

input DeviceResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: DeviceResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input DeviceResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: DeviceResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input DeviceResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: Void!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input DeviceResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: DeviceResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum DeviceResolverStringFilterKeys {
  expoPushToken
}

type EffectiveCommitteeRole {
  identifier: CommitteeIdentifier!
  role: CommitteeRole!
}

"""
A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address.
"""
scalar EmailAddress @specifiedBy(url: "https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address")

type EventNode implements Node {
  createdAt: DateTimeISO
  description: String
  id: GlobalId!

  """List all images for this event"""
  images: [ImageNode!]!
  location: String
  occurrences: [EventOccurrenceNode!]!
  summary: String
  title: String!
  updatedAt: DateTimeISO
}

type EventOccurrenceNode {
  fullDay: Boolean!
  id: ID!
  interval: IntervalISO!
}

enum EventResolverAllKeys {
  createdAt
  description
  location
  occurrence
  occurrenceEnd
  occurrenceStart
  summary
  title
  updatedAt
}

enum EventResolverDateFilterKeys {
  createdAt
  occurrence
  occurrenceEnd
  occurrenceStart
  updatedAt
}

input EventResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: EventResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input EventResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: EventResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input EventResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: Void!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input EventResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: EventResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum EventResolverStringFilterKeys {
  description
  location
  summary
  title
}

type FeedNode implements Node {
  createdAt: DateTimeISO
  id: GlobalId!

  """The image associated with this feed item"""
  image: ImageNode
  textContent: String
  title: String!
  updatedAt: DateTimeISO
}

type FundraisingAssignmentNode implements Node {
  amount: Float!
  createdAt: DateTimeISO
  entry: FundraisingEntryNode!
  id: GlobalId!

  """
  The person assigned to this assignment, only null when access is denied
  """
  person: PersonNode
  updatedAt: DateTimeISO
}

type FundraisingEntryNode implements Node {
  amount: Float!
  amountUnassigned: Float!
  assignments: [FundraisingAssignmentNode!]!
  createdAt: DateTimeISO
  donatedByText: String
  donatedOn: DateTimeISO!
  donatedToText: String
  id: GlobalId!
  updatedAt: DateTimeISO
}

enum FundraisingEntryResolverAllKeys {
  amount
  amountUnassigned
  createdAt
  donatedBy
  donatedOn
  donatedTo
  updatedAt
}

enum FundraisingEntryResolverDateFilterKeys {
  createdAt
  donatedOn
  updatedAt
}

input FundraisingEntryResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: FundraisingEntryResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input FundraisingEntryResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: FundraisingEntryResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input FundraisingEntryResolverKeyedNumericFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: FundraisingEntryResolverNumericFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: Float!
}

input FundraisingEntryResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: FundraisingEntryResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input FundraisingEntryResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: FundraisingEntryResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum FundraisingEntryResolverNumericFilterKeys {
  amount
  amountUnassigned
}

enum FundraisingEntryResolverOneOfFilterKeys {
  teamId
}

enum FundraisingEntryResolverStringFilterKeys {
  donatedBy
  donatedTo
}

type GetAllConfigurationsResponse implements AbstractGraphQLArrayOkResponse & GraphQLBaseResponse {
  data: [ConfigurationNode!]!
  ok: Boolean!
}

type GetConfigurationByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ConfigurationNode!
  ok: Boolean!
}

type GetDeviceByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: DeviceNode!
  ok: Boolean!
}

type GetEventByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: EventNode!
  ok: Boolean!
}

type GetImageByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ImageNode!
  ok: Boolean!
}

type GetNotificationByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: NotificationNode!
  ok: Boolean!
}

type GetPointEntryByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointEntryNode!
  ok: Boolean!
}

"""GlobalId custom scalar type"""
scalar GlobalId

"""API response"""
interface GraphQLBaseResponse {
  ok: Boolean!
}

type ImageNode implements Node {
  alt: String
  createdAt: DateTimeISO
  height: Int!
  id: GlobalId!
  mimeType: String!
  thumbHash: String
  updatedAt: DateTimeISO
  url: URL
  width: Int!
}

enum ImageResolverAllKeys {
  alt
  createdAt
  height
  updatedAt
  width
}

enum ImageResolverDateFilterKeys {
  createdAt
  updatedAt
}

input ImageResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: ImageResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input ImageResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: ImageResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input ImageResolverKeyedNumericFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: ImageResolverNumericFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: Float!
}

input ImageResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: Void!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input ImageResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: ImageResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum ImageResolverNumericFilterKeys {
  height
  width
}

enum ImageResolverStringFilterKeys {
  alt
}

type IntervalISO {
  end: DateTimeISO!
  start: DateTimeISO!
}

input IntervalISOInput {
  end: DateTimeISO!
  start: DateTimeISO!
}

type ListDevicesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [DeviceNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListEventsResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [EventNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListFundraisingEntriesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [FundraisingEntryNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListImagesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [ImageNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListMarathonsResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [MarathonNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListNotificationDeliveriesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [NotificationDeliveryNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListNotificationsResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [NotificationNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPeopleResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [PersonNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPointEntriesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [PointEntryNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPointOpportunitiesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [PointOpportunityNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListTeamsResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [TeamNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type LoginState {
  accessLevel: AccessLevel!
  authSource: AuthSource!
  dbRole: DbRole!
  effectiveCommitteeRoles: [EffectiveCommitteeRole!]!
  loggedIn: Boolean!
}

type MarathonHourNode implements Node {
  createdAt: DateTimeISO
  details: String
  durationInfo: String!
  id: GlobalId!
  mapImages: [ImageNode!]!
  shownStartingAt: DateTimeISO!
  title: String!
  updatedAt: DateTimeISO
}

type MarathonNode implements Node {
  communityDevelopmentCommitteeTeam: TeamNode!
  corporateCommitteeTeam: TeamNode!
  createdAt: DateTimeISO
  dancerRelationsCommitteeTeam: TeamNode!
  endDate: DateTimeISO
  familyRelationsCommitteeTeam: TeamNode!
  fundraisingCommitteeTeam: TeamNode!
  hours: [MarathonHourNode!]!
  id: GlobalId!
  marketingCommitteeTeam: TeamNode!
  miniMarathonsCommitteeTeam: TeamNode!
  operationsCommitteeTeam: TeamNode!
  overallCommitteeTeam: TeamNode!
  programmingCommitteeTeam: TeamNode!
  startDate: DateTimeISO
  techCommitteeTeam: TeamNode!
  updatedAt: DateTimeISO
  viceCommitteeTeam: TeamNode!
  year: String!
}

enum MarathonResolverAllKeys {
  createdAt
  endDate
  startDate
  updatedAt
  year
}

enum MarathonResolverDateFilterKeys {
  createdAt
  endDate
  startDate
  updatedAt
}

input MarathonResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: MarathonResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input MarathonResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: MarathonResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input MemberOf {
  committeeRole: CommitteeRole
  id: GlobalId!
}

type MembershipNode implements Node {
  committeeRole: CommitteeRole
  createdAt: DateTimeISO
  id: GlobalId!
  person: PersonNode!
  position: MembershipPositionType!
  team: TeamNode!
  updatedAt: DateTimeISO
}

"""The position of a member on a team"""
enum MembershipPositionType {
  Captain
  Member
}

type Mutation {
  abortScheduledNotification(uuid: GlobalId!): AbortScheduledNotificationResponse!
  acknowledgeDeliveryIssue(uuid: GlobalId!): AcknowledgeDeliveryIssueResponse!

  """Add an existing image to an event"""
  addExistingImageToEvent(eventId: GlobalId!, imageId: GlobalId!): AddEventImageResponse!
  addMap(imageUuid: GlobalId!, uuid: GlobalId!): MarathonHourNode!
  addPersonToTeam(personUuid: GlobalId!, position: MembershipPositionType! = Member, teamUuid: GlobalId!): MembershipNode!
  assignEntryToPerson(entryId: GlobalId!, input: AssignEntryToPersonInput!, personId: GlobalId!): FundraisingAssignmentNode!
  assignTeamToDbFundsTeam(dbFundsTeamDbNum: Int!, teamId: GlobalId!): Void!

  """Attach an image to a feed item"""
  attachImageToFeedItem(feedItemUuid: GlobalId!, imageUuid: GlobalId!): FeedNode!
  bulkLoadPeople(marathonId: GlobalId!, people: [BulkPersonInput!]!): [PersonNode!]!
  bulkLoadTeams(marathonId: GlobalId!, teams: [BulkTeamInput!]!): [TeamNode!]!

  """
  Create a new configuration, superseding existing configurations with the same key (depending on the validAfter and validUntil fields)
  """
  createConfiguration(input: CreateConfigurationInput!): CreateConfigurationResponse!

  """
  Create multiple configurations, superseding existing configurations with the same key (depending on the validAfter and validUntil fields)
  """
  createConfigurations(input: [CreateConfigurationInput!]!): CreateConfigurationResponse!

  """Create a new event"""
  createEvent(input: CreateEventInput!): CreateEventResponse!

  """Add a new item to the feed"""
  createFeedItem(input: CreateFeedInput!): FeedNode!
  createImage(input: CreateImageInput!): ImageNode!
  createMarathon(input: CreateMarathonInput!): MarathonNode!
  createMarathonHour(input: CreateMarathonHourInput!, marathonUuid: GlobalId!): MarathonHourNode!
  createPerson(input: CreatePersonInput!): PersonNode!
  createPointEntry(input: CreatePointEntryInput!): CreatePointEntryResponse!
  createPointOpportunity(input: CreatePointOpportunityInput!): CreatePointOpportunityResponse!
  createTeam(input: CreateTeamInput!, marathon: GlobalId!): CreateTeamResponse!

  """Delete a configuration by UUID"""
  deleteConfiguration(uuid: GlobalId!): DeleteConfigurationResponse!

  """Delete a device by it's UUID"""
  deleteDevice(uuid: GlobalId!): DeleteDeviceResponse!

  """Delete an event by UUID"""
  deleteEvent(uuid: GlobalId!): DeleteEventResponse!

  """Delete a feed item"""
  deleteFeedItem(feedItemUuid: GlobalId!): Boolean!
  deleteFundraisingAssignment(id: GlobalId!): FundraisingAssignmentNode!
  deleteImage(uuid: GlobalId!): DeleteImageResponse!
  deleteMarathon(uuid: GlobalId!): MarathonNode!
  deleteMarathonHour(uuid: GlobalId!): Void!
  deleteNotification(
    """
    If true, the notification will be deleted even if it has already been sent, which will also delete the delivery records.
    """
    force: Boolean
    uuid: GlobalId!
  ): DeleteNotificationResponse!
  deletePerson(uuid: GlobalId!): PersonNode!
  deletePointEntry(uuid: GlobalId!): DeletePointEntryResponse!
  deletePointOpportunity(uuid: GlobalId!): DeletePointOpportunityResponse!
  deleteTeam(uuid: GlobalId!): DeleteTeamResponse!

  """Register a new device, or update an existing one"""
  registerDevice(input: RegisterDeviceInput!): RegisterDeviceResponse!

  """Remove an image from an event"""
  removeImageFromEvent(eventId: GlobalId!, imageId: GlobalId!): RemoveEventImageResponse!

  """Remove an image from a feed item"""
  removeImageFromFeedItem(feedItemUuid: GlobalId!): FeedNode!
  removeMap(imageUuid: GlobalId!, uuid: GlobalId!): Void!
  removePersonFromTeam(personUuid: GlobalId!, teamUuid: GlobalId!): MembershipNode!
  scheduleNotification(sendAt: DateTimeISO!, uuid: GlobalId!): ScheduleNotificationResponse!

  """Send a notification immediately."""
  sendNotification(uuid: GlobalId!): SendNotificationResponse!

  """Update an event by UUID"""
  setEvent(input: SetEventInput!, uuid: GlobalId!): SetEventResponse!

  """Set the content of a feed item"""
  setFeedItem(feedItemUuid: GlobalId!, input: SetFeedInput!): FeedNode!
  setImageAltText(alt: String!, uuid: GlobalId!): ImageNode!
  setImageUrl(url: URL!, uuid: GlobalId!): ImageNode!
  setMarathon(input: SetMarathonInput!, uuid: GlobalId!): MarathonNode!
  setMarathonHour(input: SetMarathonHourInput!, uuid: GlobalId!): MarathonHourNode!
  setPerson(input: SetPersonInput!, uuid: GlobalId!): PersonNode!
  setPointOpportunity(input: SetPointOpportunityInput!, uuid: GlobalId!): SinglePointOpportunityResponse!
  setTeam(input: SetTeamInput!, uuid: GlobalId!): SingleTeamResponse!
  stageNotification(audience: NotificationAudienceInput!, body: String!, title: String!, url: String): StageNotificationResponse!
  updateFundraisingAssignment(id: GlobalId!, input: UpdateFundraisingAssignmentInput!): FundraisingAssignmentNode!
}

interface Node {
  id: GlobalId!
}

"""Integers that will have a value of 0 or more."""
scalar NonNegativeInt

input NotificationAudienceInput {
  all: Boolean
  memberOfTeamType: TeamType
  memberOfTeams: [GlobalId!]
  users: [GlobalId!]
}

"""The number of delivery issues for a notification, broken down by type."""
type NotificationDeliveryIssueCount {
  DeviceNotRegistered: Int!
  InvalidCredentials: Int!
  MessageRateExceeded: Int!
  MessageTooBig: Int!
  MismatchSenderId: Int!
  Unknown: Int!
}

type NotificationDeliveryNode implements Node {
  """
  A unique identifier corresponding the group of notifications this was sent to Expo with.
  """
  chunkUuid: String
  createdAt: DateTimeISO

  """Any error message returned by Expo when sending the notification."""
  deliveryError: String
  id: GlobalId!
  notification: NotificationNode!

  """The time the server received a delivery receipt from the user."""
  receiptCheckedAt: DateTimeISO

  """The time the server sent the notification to Expo for delivery."""
  sentAt: DateTimeISO
  updatedAt: DateTimeISO
}

enum NotificationDeliveryResolverAllKeys {
  createdAt
  deliveryError
  receiptCheckedAt
  sentAt
  updatedAt
}

enum NotificationDeliveryResolverDateFilterKeys {
  createdAt
  receiptCheckedAt
  sentAt
  updatedAt
}

input NotificationDeliveryResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: NotificationDeliveryResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input NotificationDeliveryResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: NotificationDeliveryResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

type NotificationNode implements Node {
  body: String!
  createdAt: DateTimeISO
  deliveryCount: Int!
  deliveryIssue: String
  deliveryIssueAcknowledgedAt: DateTimeISO
  deliveryIssueCount: NotificationDeliveryIssueCount!
  id: GlobalId!

  """
  The time the notification is scheduled to be sent, if null it is either already sent or unscheduled.
  """
  sendAt: DateTimeISO

  """The time the server started sending the notification."""
  startedSendingAt: DateTimeISO
  title: String!
  updatedAt: DateTimeISO
  url: URL
}

enum NotificationResolverAllKeys {
  body
  createdAt
  deliveryIssue
  sendAt
  startedSendingAt
  title
  updatedAt
}

enum NotificationResolverDateFilterKeys {
  createdAt
  sendAt
  startedSendingAt
  updatedAt
}

input NotificationResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: NotificationResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input NotificationResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: NotificationResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input NotificationResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: NotificationResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input NotificationResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: NotificationResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum NotificationResolverOneOfFilterKeys {
  deliveryIssue
}

enum NotificationResolverStringFilterKeys {
  body
  title
}

enum NumericComparator {
  EQUALS
  GREATER_THAN
  GREATER_THAN_OR_EQUAL_TO
  IS
  LESS_THAN
  LESS_THAN_OR_EQUAL_TO
}

type PersonNode implements Node {
  assignedDonationEntries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [FundraisingEntryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [FundraisingEntryResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [FundraisingEntryResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [FundraisingEntryResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [FundraisingEntryResolverKeyedStringFilterItem!]
  ): ListFundraisingEntriesResponse
  committees: [CommitteeMembershipNode!]!
  createdAt: DateTimeISO
  dbRole: DbRole!
  email: String!
  fundraisingAssignments: [FundraisingAssignmentNode!]!
  fundraisingTotalAmount: Float
  id: GlobalId!
  linkblue: String
  moraleTeams: [MembershipNode!]!
  name: String
  primaryCommittee: CommitteeMembershipNode
  primaryTeam(teamType: TeamType!): MembershipNode
  teams: [MembershipNode!]!
  updatedAt: DateTimeISO
}

enum PersonResolverAllKeys {
  committeeName
  committeeRole
  dbRole
  email
  linkblue
  name
}

input PersonResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PersonResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input PersonResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: PersonResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input PersonResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: PersonResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum PersonResolverOneOfFilterKeys {
  committeeName
  committeeRole
  dbRole
}

enum PersonResolverStringFilterKeys {
  email
  linkblue
  name
}

type PointEntryNode implements Node {
  comment: String
  createdAt: DateTimeISO
  id: GlobalId!
  personFrom: PersonNode
  pointOpportunity: PointOpportunityNode
  points: Int!
  team: TeamNode!
  updatedAt: DateTimeISO
}

enum PointEntryResolverAllKeys {
  createdAt
  updatedAt
}

enum PointEntryResolverDateFilterKeys {
  createdAt
  updatedAt
}

input PointEntryResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: PointEntryResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input PointEntryResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PointEntryResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

type PointOpportunityNode implements Node {
  createdAt: DateTimeISO
  event: EventNode
  id: GlobalId!
  name: String!
  opportunityDate: DateTimeISO
  type: TeamType!
  updatedAt: DateTimeISO
}

enum PointOpportunityResolverAllKeys {
  createdAt
  marathonUuid
  name
  opportunityDate
  type
  updatedAt
}

enum PointOpportunityResolverDateFilterKeys {
  createdAt
  opportunityDate
  updatedAt
}

input PointOpportunityResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: PointOpportunityResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input PointOpportunityResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PointOpportunityResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input PointOpportunityResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: PointOpportunityResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input PointOpportunityResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: PointOpportunityResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum PointOpportunityResolverOneOfFilterKeys {
  marathonUuid
  type
}

enum PointOpportunityResolverStringFilterKeys {
  name
}

"""Integers that will have a value greater than 0."""
scalar PositiveInt

type Query {
  """Get the active configuration for a given key at the current time"""
  activeConfiguration(key: String!): GetConfigurationByUuidResponse!

  """Get all configurations, irrespective of time"""
  allConfigurations: GetAllConfigurationsResponse!

  """Get the audit log file from the server"""
  auditLog(lines: Float! = 25, offset: Float! = 0): String!

  """Get a particular configuration entry by UUID"""
  configuration(id: GlobalId!): GetConfigurationByUuidResponse!

  """
  The marathon that is currently happening, i.e. the marathon with the latest start date that has not yet ended.
  """
  currentMarathon: MarathonNode
  currentMarathonHour: MarathonHourNode
  dbFundsTeams(search: String!): [DbFundsTeamInfo!]!

  """Get a device by it's UUID"""
  device(
    """For legacy reasons, this can be a GlobalId or a raw UUID"""
    uuid: String!
  ): GetDeviceByUuidResponse!

  """List all devices"""
  devices(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [DeviceResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [DeviceResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [DeviceResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [DeviceResolverKeyedStringFilterItem!]
  ): ListDevicesResponse!

  """Get an event by UUID"""
  event(uuid: GlobalId!): GetEventByUuidResponse!

  """List events"""
  events(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [EventResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [EventResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [EventResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [EventResolverKeyedStringFilterItem!]
  ): ListEventsResponse!

  """Get the active feed"""
  feed(limit: Int = 10): [FeedNode!]!

  """Get a feed item by its UUID"""
  feedItem(feedItemId: GlobalId!): FeedNode!
  fundraisingAssignment(id: GlobalId!): FundraisingAssignmentNode!
  fundraisingEntries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [FundraisingEntryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [FundraisingEntryResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [FundraisingEntryResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [FundraisingEntryResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [FundraisingEntryResolverKeyedStringFilterItem!]
  ): ListFundraisingEntriesResponse!
  fundraisingEntry(id: GlobalId!): FundraisingEntryNode!
  image(uuid: GlobalId!): GetImageByUuidResponse!
  images(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [ImageResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [ImageResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [ImageResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [ImageResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [ImageResolverKeyedStringFilterItem!]
  ): ListImagesResponse!

  """
  The most recent marathon, regardless of whether it is currently happening, i.e. the marathon with the latest year.
  """
  latestMarathon: MarathonNode
  listPeople(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: Void

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [PersonResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [PersonResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [PersonResolverKeyedStringFilterItem!]
  ): ListPeopleResponse!
  loginState: LoginState!
  marathon(uuid: GlobalId!): MarathonNode!
  marathonForYear(year: String!): MarathonNode!
  marathonHour(uuid: GlobalId!): MarathonHourNode!
  marathons(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [MarathonResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [MarathonResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: Void

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: Void
  ): ListMarathonsResponse!
  me: PersonNode
  node(id: GlobalId!): Node!
  notification(uuid: GlobalId!): GetNotificationByUuidResponse!
  notificationDeliveries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [NotificationDeliveryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [NotificationDeliveryResolverKeyedIsNullFilterItem!]
    notificationUuid: GlobalId!

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: Void

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: Void
  ): ListNotificationDeliveriesResponse!
  notifications(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [NotificationResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [NotificationResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [NotificationResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [NotificationResolverKeyedStringFilterItem!]
  ): ListNotificationsResponse!
  person(uuid: GlobalId!): PersonNode!
  personByLinkBlue(linkBlueId: String!): PersonNode
  pointEntries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [PointEntryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [PointEntryResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: Void

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: Void
  ): ListPointEntriesResponse!
  pointEntry(uuid: GlobalId!): GetPointEntryByUuidResponse!
  pointOpportunities(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [PointOpportunityResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [PointOpportunityResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [PointOpportunityResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [PointOpportunityResolverKeyedStringFilterItem!]
  ): ListPointOpportunitiesResponse!
  pointOpportunity(uuid: GlobalId!): SinglePointOpportunityResponse!
  rawFundraisingEntries(identifier: Int!, marathonYear: String!): String!
  rawFundraisingTotals(marathonYear: String!): String!
  searchPeopleByName(name: String!): [PersonNode!]!
  team(uuid: GlobalId!): SingleTeamResponse!
  teams(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: Void

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [TeamResolverKeyedIsNullFilterItem!]
    legacyStatus: [TeamLegacyStatus!]
    marathonId: [GlobalId!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [TeamResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [TeamResolverKeyedStringFilterItem!]
    type: [TeamType!]
    visibility: [DbRole!] @deprecated(reason: "Use type")
  ): ListTeamsResponse!
}

input RegisterDeviceInput {
  """For legacy reasons, this can be a GlobalId or a raw UUID"""
  deviceId: String!

  """The Expo push token of the device"""
  expoPushToken: String

  """The ID of the last user to log in on this device"""
  lastUserId: GlobalId

  """base64 encoded SHA-256 hash of a secret known to the device"""
  verifier: String!
}

type RegisterDeviceResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: DeviceNode!
  ok: Boolean!
}

type RemoveEventImageResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

type ScheduleNotificationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

type SendNotificationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

input SetEventInput {
  description: String
  location: String
  occurrences: [SetEventOccurrenceInput!]!
  summary: String
  title: String!
}

input SetEventOccurrenceInput {
  fullDay: Boolean!
  interval: IntervalISOInput!

  """
  If updating an existing occurrence, the UUID of the occurrence to update
  """
  uuid: GlobalId
}

type SetEventResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: EventNode!
  ok: Boolean!
}

input SetFeedInput {
  textContent: String
  title: String!
}

input SetMarathonHourInput {
  details: String
  durationInfo: String!
  shownStartingAt: DateTimeISO!
  title: String!
}

input SetMarathonInput {
  endDate: DateTimeISO
  startDate: DateTimeISO
  year: String!
}

input SetPersonInput {
  captainOf: [MemberOf!]
  email: EmailAddress
  linkblue: String
  memberOf: [MemberOf!]
  name: String
}

input SetPointOpportunityInput {
  eventUuid: GlobalId
  name: String
  opportunityDate: DateTimeISO
  type: TeamType
}

input SetTeamInput {
  legacyStatus: TeamLegacyStatus
  name: String
  persistentIdentifier: String
  type: TeamType
}

type SinglePointOpportunityResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointOpportunityNode!
  ok: Boolean!
}

type SingleTeamResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: TeamNode!
  ok: Boolean!
}

enum SortDirection {
  asc
  desc
}

type StageNotificationResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: NotificationNode!
  ok: Boolean!
  uuid: GlobalId!
}

enum StringComparator {
  ENDS_WITH
  EQUALS
  IS
  STARTS_WITH
  SUBSTRING
}

"""New Team vs Returning Team"""
enum TeamLegacyStatus {
  DemoTeam
  NewTeam
  ReturningTeam
}

type TeamNode implements Node {
  captains: [MembershipNode!]! @deprecated(reason: "Just query the members field and filter by role")
  committeeIdentifier: CommitteeIdentifier
  createdAt: DateTimeISO
  dbFundsTeam: DbFundsTeamInfo
  fundraisingEntries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [FundraisingEntryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [FundraisingEntryResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [FundraisingEntryResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [FundraisingEntryResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [FundraisingEntryResolverKeyedStringFilterItem!]
  ): ListFundraisingEntriesResponse!
  fundraisingTotalAmount: Float
  id: GlobalId!
  legacyStatus: TeamLegacyStatus!
  marathon: MarathonNode!
  members: [MembershipNode!]!
  name: String!
  pointEntries: [PointEntryNode!]!
  totalPoints: Int!
  type: TeamType!
  updatedAt: DateTimeISO
}

enum TeamResolverAllKeys {
  legacyStatus
  marathonId
  name
  type
}

input TeamResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: TeamResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input TeamResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: TeamResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input TeamResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: TeamResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum TeamResolverOneOfFilterKeys {
  legacyStatus
  marathonId
  type
}

enum TeamResolverStringFilterKeys {
  name
}

"""Types of teams"""
enum TeamType {
  Morale
  Spirit
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

input UpdateFundraisingAssignmentInput {
  amount: Float!
}

"""Represents NULL values"""
scalar Void