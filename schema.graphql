# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AbortScheduledNotificationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

"""API response"""
interface AbstractGraphQLArrayOkResponse implements GraphQLBaseResponse {
  ok: Boolean!
}

"""API response"""
interface AbstractGraphQLCreatedResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
  uuid: String!
}

"""API response"""
interface AbstractGraphQLOkResponse implements GraphQLBaseResponse {
  ok: Boolean!
}

"""API response"""
interface AbstractGraphQLPaginatedResponse implements AbstractGraphQLArrayOkResponse & GraphQLBaseResponse {
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type AcknowledgeDeliveryIssueResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

type AddEventImageResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ImageNode!
  ok: Boolean!
}

"""The source of authentication"""
enum AuthSource {
  Anonymous
  Demo
  LinkBlue
  None
}

"""The identifier for a committee"""
enum CommitteeIdentifier {
  communityDevelopmentCommittee
  corporateCommittee
  dancerRelationsCommittee
  familyRelationsCommittee
  fundraisingCommittee
  marketingCommittee
  miniMarathonsCommittee
  operationsCommittee
  overallCommittee
  programmingCommittee
  techCommittee
  viceCommittee
}

type CommitteeMembershipNode implements Node {
  createdAt: DateTimeISO
  id: ID!
  identifier: CommitteeIdentifier!
  person: PersonNode!
  position: MembershipPositionType!
  role: CommitteeRole!
  team: TeamNode!
  updatedAt: DateTimeISO
}

"""Roles within a committee"""
enum CommitteeRole {
  Chair
  Coordinator
  Member
}

type ConfigurationNode implements Node {
  createdAt: DateTimeISO
  id: ID!
  key: String!
  updatedAt: DateTimeISO
  validAfter: DateTimeISO
  validUntil: DateTimeISO
  value: String!
}

input CreateConfigurationInput {
  key: String!
  validAfter: DateTimeISO
  validUntil: DateTimeISO
  value: String!
}

type CreateConfigurationResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ConfigurationNode!
  ok: Boolean!
  uuid: String!
}

input CreateEventInput {
  description: String
  location: String
  occurrences: [CreateEventOccurrenceInput!]!
  summary: String
  title: String!
}

input CreateEventOccurrenceInput {
  fullDay: Boolean!
  interval: IntervalISOInput!
}

type CreateEventResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: EventNode!
  ok: Boolean!
  uuid: String!
}

input CreateFeedInput {
  imageUuid: String
  textContent: String
  title: String!
}

input CreateImageInput {
  alt: String
  url: URL
}

input CreateMarathonHourInput {
  details: String
  durationInfo: String!
  shownStartingAt: DateTimeISO!
  title: String!
}

input CreateMarathonInput {
  endDate: DateTimeISO!
  startDate: DateTimeISO!
  year: String!
}

input CreatePersonInput {
  captainOf: [String!]! = []
  dbRole: DbRole
  email: EmailAddress!
  linkblue: String
  memberOf: [String!]! = []
  name: String
}

type CreatePersonResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PersonNode!
  ok: Boolean!
  uuid: String!
}

input CreatePointEntryInput {
  comment: String
  opportunityUuid: String
  personFromUuid: String
  points: Int!
  teamUuid: String!
}

type CreatePointEntryResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointEntryNode!
  ok: Boolean!
  uuid: String!
}

input CreatePointOpportunityInput {
  eventUuid: ID
  name: String!
  opportunityDate: DateTimeISO
  type: TeamType!
}

type CreatePointOpportunityResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointOpportunityNode!
  ok: Boolean!
  uuid: String!
}

input CreateTeamInput {
  legacyStatus: TeamLegacyStatus!
  marathonYear: String!
  name: String!
  persistentIdentifier: String
  type: TeamType!
}

type CreateTeamResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: TeamNode!
  ok: Boolean!
  uuid: String!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

"""DanceBlue roles"""
enum DbRole {
  Committee
  None
  Public
  UKY
}

type DeleteConfigurationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteDeviceResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteEventResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteImageResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteNotificationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

type DeletePersonResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeletePointEntryResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeletePointOpportunityResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteTeamResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeviceNode implements Node {
  createdAt: DateTimeISO
  id: ID!
  lastLoggedInUser: PersonNode
  lastLogin: DateTimeISO
  notificationDeliveries(
    page: Int = 1
    pageSize: Int = 10

    """
    The verifier code for this device, if it does not match then the query will be rejected
    """
    verifier: String
  ): [NotificationDeliveryNode!]!
  updatedAt: DateTimeISO
}

enum DeviceResolverAllKeys {
  createdAt
  expoPushToken
  lastSeen
  updatedAt
}

enum DeviceResolverDateFilterKeys {
  createdAt
  lastSeen
  updatedAt
}

input DeviceResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: DeviceResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input DeviceResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: DeviceResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input DeviceResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: Void!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input DeviceResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: DeviceResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum DeviceResolverStringFilterKeys {
  expoPushToken
}

type EffectiveCommitteeRole {
  committee: CommitteeIdentifier!
  role: CommitteeRole!
}

"""
A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address.
"""
scalar EmailAddress @specifiedBy(url: "https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address")

type EventNode implements Node {
  createdAt: DateTimeISO
  description: String
  id: ID!
  images: [ImageNode!]!
  location: String
  occurrences: [EventOccurrenceNode!]!
  summary: String
  title: String!
  updatedAt: DateTimeISO
}

type EventOccurrenceNode {
  fullDay: Boolean!
  interval: IntervalISO!
  uuid: ID!
}

enum EventResolverAllKeys {
  createdAt
  description
  location
  occurrence
  occurrenceEnd
  occurrenceStart
  summary
  title
  updatedAt
}

enum EventResolverDateFilterKeys {
  createdAt
  occurrence
  occurrenceEnd
  occurrenceStart
  updatedAt
}

input EventResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: EventResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input EventResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: EventResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input EventResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: Void!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input EventResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: EventResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum EventResolverStringFilterKeys {
  description
  location
  summary
  title
}

type FeedNode implements Node {
  createdAt: DateTimeISO
  id: ID!
  image: ImageNode
  textContent: String
  title: String!
  updatedAt: DateTimeISO
}

type GetAllConfigurationsResponse implements AbstractGraphQLArrayOkResponse & GraphQLBaseResponse {
  data: [ConfigurationNode!]!
  ok: Boolean!
}

type GetConfigurationByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ConfigurationNode!
  ok: Boolean!
}

type GetDeviceByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: DeviceNode!
  ok: Boolean!
}

type GetEventByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: EventNode!
  ok: Boolean!
}

type GetImageByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ImageNode!
  ok: Boolean!
}

type GetMembershipResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: MembershipNode
  ok: Boolean!
}

type GetNotificationByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: NotificationNode!
  ok: Boolean!
}

type GetPeopleResponse implements AbstractGraphQLArrayOkResponse & GraphQLBaseResponse {
  data: [PersonNode!]!
  ok: Boolean!
}

type GetPersonResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PersonNode
  ok: Boolean!
}

type GetPointEntryByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointEntryNode!
  ok: Boolean!
}

"""API response"""
interface GraphQLBaseResponse {
  ok: Boolean!
}

type ImageNode implements Node {
  alt: String
  createdAt: DateTimeISO
  height: Int!
  id: ID!
  mimeType: String!
  thumbHash: String
  updatedAt: DateTimeISO
  url: URL
  width: Int!
}

enum ImageResolverAllKeys {
  alt
  createdAt
  height
  updatedAt
  width
}

enum ImageResolverDateFilterKeys {
  createdAt
  updatedAt
}

input ImageResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: ImageResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input ImageResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: ImageResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input ImageResolverKeyedNumericFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: ImageResolverNumericFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: Float!
}

input ImageResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: Void!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input ImageResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: ImageResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum ImageResolverNumericFilterKeys {
  height
  width
}

enum ImageResolverStringFilterKeys {
  alt
}

type IntervalISO {
  end: DateTimeISO!
  start: DateTimeISO!
}

input IntervalISOInput {
  end: DateTimeISO!
  start: DateTimeISO!
}

type ListDevicesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [DeviceNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListEventsResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [EventNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListImagesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [ImageNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListMarathonsResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [MarathonNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListNotificationDeliveriesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [NotificationDeliveryNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListNotificationsResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [NotificationNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPeopleResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [PersonNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPointEntriesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [PointEntryNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPointOpportunitiesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [PointOpportunityNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListTeamsResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [TeamNode!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type LoginState {
  authSource: AuthSource!
  dbRole: DbRole!
  effectiveCommitteeRoles: [EffectiveCommitteeRole!]!
  loggedIn: Boolean!
  person: PersonNode
}

type MarathonHourNode implements Node {
  createdAt: DateTimeISO
  details: String
  durationInfo: String!
  id: ID!
  mapImages: [ImageNode!]!
  shownStartingAt: DateTimeISO!
  title: String!
  updatedAt: DateTimeISO
}

type MarathonNode implements Node {
  communityDevelopmentCommitteeTeam: TeamNode!
  corporateCommitteeTeam: TeamNode!
  createdAt: DateTimeISO
  dancerRelationsCommitteeTeam: TeamNode!
  endDate: DateTimeISO
  familyRelationsCommitteeTeam: TeamNode!
  fundraisingCommitteeTeam: TeamNode!
  hours: [MarathonHourNode!]!
  id: ID!
  marketingCommitteeTeam: TeamNode!
  miniMarathonsCommitteeTeam: TeamNode!
  operationsCommitteeTeam: TeamNode!
  overallCommitteeTeam: TeamNode!
  programmingCommitteeTeam: TeamNode!
  startDate: DateTimeISO
  techCommitteeTeam: TeamNode!
  updatedAt: DateTimeISO
  viceCommitteeTeam: TeamNode!
  year: String!
}

enum MarathonResolverAllKeys {
  createdAt
  endDate
  startDate
  updatedAt
  year
}

enum MarathonResolverDateFilterKeys {
  createdAt
  endDate
  startDate
  updatedAt
}

input MarathonResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: MarathonResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input MarathonResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: MarathonResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

type MembershipNode implements Node {
  createdAt: DateTimeISO
  id: ID!
  person: PersonNode!
  position: MembershipPositionType!
  team: TeamNode!
  updatedAt: DateTimeISO
}

"""The position of a member on a team"""
enum MembershipPositionType {
  Captain
  Member
}

type Mutation {
  abortScheduledNotification(uuid: String!): AbortScheduledNotificationResponse!
  acknowledgeDeliveryIssue(uuid: String!): AcknowledgeDeliveryIssueResponse!
  addExistingImageToEvent(eventId: String!, imageId: String!): AddEventImageResponse!
  addMap(imageUuid: String!, uuid: String!): MarathonHourNode!
  addPersonToTeam(personUuid: String!, teamUuid: String!): GetMembershipResponse!
  attachImageToFeedItem(feedItemUuid: String!, imageUuid: String!): FeedNode!
  createConfiguration(input: CreateConfigurationInput!): CreateConfigurationResponse!
  createConfigurations(input: [CreateConfigurationInput!]!): CreateConfigurationResponse!
  createEvent(input: CreateEventInput!): CreateEventResponse!
  createFeedItem(input: CreateFeedInput!): FeedNode!
  createImage(input: CreateImageInput!): ImageNode!
  createMarathon(input: CreateMarathonInput!): MarathonNode!
  createMarathonHour(input: CreateMarathonHourInput!, marathonUuid: String!): MarathonHourNode!
  createPerson(input: CreatePersonInput!): CreatePersonResponse!
  createPointEntry(input: CreatePointEntryInput!): CreatePointEntryResponse!
  createPointOpportunity(input: CreatePointOpportunityInput!): CreatePointOpportunityResponse!
  createTeam(input: CreateTeamInput!, marathon: String!): CreateTeamResponse!
  deleteConfiguration(uuid: String!): DeleteConfigurationResponse!
  deleteDevice(uuid: String!): DeleteDeviceResponse!
  deleteEvent(uuid: String!): DeleteEventResponse!
  deleteFeedItem(feedItemUuid: String!): Boolean!
  deleteImage(uuid: String!): DeleteImageResponse!
  deleteMarathon(uuid: String!): Void!
  deleteMarathonHour(uuid: String!): Void!
  deleteNotification(
    """
    If true, the notification will be deleted even if it has already been sent, which will also delete the delivery records.
    """
    force: Boolean
    uuid: String!
  ): DeleteNotificationResponse!
  deletePerson(uuid: String!): DeletePersonResponse!
  deletePointEntry(uuid: String!): DeletePointEntryResponse!
  deletePointOpportunity(uuid: String!): DeletePointOpportunityResponse!
  deleteTeam(uuid: String!): DeleteTeamResponse!
  registerDevice(input: RegisterDeviceInput!): RegisterDeviceResponse!
  removeImageFromEvent(eventId: String!, imageId: String!): RemoveEventImageResponse!
  removeImageFromFeedItem(feedItemUuid: String!): FeedNode!
  removeMap(imageUuid: String!, uuid: String!): Void!
  scheduleNotification(sendAt: DateTimeISO!, uuid: String!): ScheduleNotificationResponse!

  """Send a notification immediately."""
  sendNotification(uuid: String!): SendNotificationResponse!
  setEvent(input: SetEventInput!, uuid: String!): SetEventResponse!
  setFeedItem(feedItemUuid: String!, input: SetFeedInput!): FeedNode!
  setImageAltText(alt: String!, uuid: String!): ImageNode!
  setImageUrl(uuid: String!): ImageNode!
  setMarathon(input: SetMarathonInput!, uuid: String!): MarathonNode!
  setMarathonHour(input: SetMarathonHourInput!, uuid: String!): MarathonHourNode!
  setPerson(input: SetPersonInput!, uuid: String!): GetPersonResponse!
  setPointOpportunity(input: SetPointOpportunityInput!, uuid: String!): SinglePointOpportunityResponse!
  setTeam(input: SetTeamInput!, uuid: String!): SingleTeamResponse!
  stageNotification(audience: NotificationAudienceInput!, body: String!, title: String!, url: String): StageNotificationResponse!
}

interface Node {
  id: ID!
}

"""Integers that will have a value of 0 or more."""
scalar NonNegativeInt

input NotificationAudienceInput {
  all: Boolean
  memberOfTeamType: TeamType
  memberOfTeams: [String!]
  users: [String!]
}

"""The number of delivery issues for a notification, broken down by type."""
type NotificationDeliveryIssueCount {
  DeviceNotRegistered: Int!
  InvalidCredentials: Int!
  MessageRateExceeded: Int!
  MessageTooBig: Int!
  MismatchSenderId: Int!
  Unknown: Int!
}

type NotificationDeliveryNode implements Node {
  """
  A unique identifier corresponding the group of notifications this was sent to Expo with.
  """
  chunkUuid: String
  createdAt: DateTimeISO

  """Any error message returned by Expo when sending the notification."""
  deliveryError: String
  id: ID!
  notification: NotificationNode!

  """The time the server received a delivery receipt from the user."""
  receiptCheckedAt: DateTimeISO

  """The time the server sent the notification to Expo for delivery."""
  sentAt: DateTimeISO
  updatedAt: DateTimeISO
}

enum NotificationDeliveryResolverAllKeys {
  createdAt
  deliveryError
  receiptCheckedAt
  sentAt
  updatedAt
}

enum NotificationDeliveryResolverDateFilterKeys {
  createdAt
  receiptCheckedAt
  sentAt
  updatedAt
}

input NotificationDeliveryResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: NotificationDeliveryResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input NotificationDeliveryResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: NotificationDeliveryResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

type NotificationNode implements Node {
  body: String!
  createdAt: DateTimeISO
  deliveryCount: Int!
  deliveryIssue: String
  deliveryIssueAcknowledgedAt: DateTimeISO
  deliveryIssueCount: NotificationDeliveryIssueCount!
  id: ID!

  """
  The time the notification is scheduled to be sent, if null it is either already sent or unscheduled.
  """
  sendAt: DateTimeISO

  """The time the server started sending the notification."""
  startedSendingAt: DateTimeISO
  title: String!
  updatedAt: DateTimeISO
  url: URL
}

enum NotificationResolverAllKeys {
  body
  createdAt
  deliveryIssue
  sendAt
  startedSendingAt
  title
  updatedAt
}

enum NotificationResolverDateFilterKeys {
  createdAt
  sendAt
  startedSendingAt
  updatedAt
}

input NotificationResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: NotificationResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input NotificationResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: NotificationResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input NotificationResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: NotificationResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input NotificationResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: NotificationResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum NotificationResolverOneOfFilterKeys {
  deliveryIssue
}

enum NotificationResolverStringFilterKeys {
  body
  title
}

enum NumericComparator {
  EQUALS
  GREATER_THAN
  GREATER_THAN_OR_EQUAL_TO
  IS
  LESS_THAN
  LESS_THAN_OR_EQUAL_TO
}

type PersonNode implements Node {
  committees: [CommitteeMembershipNode!]!
  createdAt: DateTimeISO
  dbRole: DbRole!
  email: String!
  id: ID!
  linkblue: String
  moraleTeams: [MembershipNode!]!
  name: String
  primaryCommittee: CommitteeMembershipNode!
  teams: [MembershipNode!]!
  updatedAt: DateTimeISO
}

enum PersonResolverAllKeys {
  committeeName
  committeeRole
  dbRole
  email
  linkblue
  name
}

input PersonResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PersonResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input PersonResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: PersonResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input PersonResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: PersonResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum PersonResolverOneOfFilterKeys {
  committeeName
  committeeRole
  dbRole
}

enum PersonResolverStringFilterKeys {
  email
  linkblue
  name
}

type PointEntryNode implements Node {
  comment: String
  createdAt: DateTimeISO
  id: ID!
  personFrom: PersonNode
  pointOpportunity: PointOpportunityNode
  points: Int!
  team: TeamNode!
  updatedAt: DateTimeISO
}

enum PointEntryResolverAllKeys {
  createdAt
  updatedAt
}

enum PointEntryResolverDateFilterKeys {
  createdAt
  updatedAt
}

input PointEntryResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: PointEntryResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input PointEntryResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PointEntryResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

type PointOpportunityNode implements Node {
  createdAt: DateTimeISO
  event: EventNode
  id: ID!
  name: String!
  opportunityDate: DateTimeISO
  type: TeamType!
  updatedAt: DateTimeISO
}

enum PointOpportunityResolverAllKeys {
  createdAt
  name
  opportunityDate
  type
  updatedAt
}

enum PointOpportunityResolverDateFilterKeys {
  createdAt
  opportunityDate
  updatedAt
}

input PointOpportunityResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: PointOpportunityResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: DateTimeISO!
}

input PointOpportunityResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PointOpportunityResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input PointOpportunityResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: PointOpportunityResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input PointOpportunityResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: PointOpportunityResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum PointOpportunityResolverOneOfFilterKeys {
  type
}

enum PointOpportunityResolverStringFilterKeys {
  name
}

"""Integers that will have a value greater than 0."""
scalar PositiveInt

type Query {
  activeConfiguration(key: String!): GetConfigurationByUuidResponse!
  allConfigurations: GetAllConfigurationsResponse!
  currentMarathon: MarathonNode
  currentMarathonHour: MarathonHourNode
  device(uuid: String!): GetDeviceByUuidResponse!
  devices(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [DeviceResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [DeviceResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [DeviceResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [DeviceResolverKeyedStringFilterItem!]
  ): ListDevicesResponse!
  event(uuid: String!): GetEventByUuidResponse!
  events(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [EventResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [EventResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [EventResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [EventResolverKeyedStringFilterItem!]
  ): ListEventsResponse!
  feed(limit: Int = 10): [FeedNode!]!
  image(uuid: String!): GetImageByUuidResponse!
  images(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [ImageResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [ImageResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [ImageResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [ImageResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [ImageResolverKeyedStringFilterItem!]
  ): ListImagesResponse!
  listPeople(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: Void

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [PersonResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [PersonResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [PersonResolverKeyedStringFilterItem!]
  ): ListPeopleResponse!
  loginState: LoginState!
  marathon(uuid: String!): MarathonNode!
  marathonForYear(year: String!): MarathonNode!
  marathonHour(uuid: String!): MarathonHourNode!
  marathons(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [MarathonResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [MarathonResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: Void

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: Void
  ): ListMarathonsResponse!
  me: GetPersonResponse!
  nextMarathon: MarathonNode
  notification(uuid: String!): GetNotificationByUuidResponse!
  notificationDeliveries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [NotificationDeliveryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [NotificationDeliveryResolverKeyedIsNullFilterItem!]
    notificationUuid: String!

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: Void

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: Void
  ): ListNotificationDeliveriesResponse!
  notifications(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [NotificationResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [NotificationResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [NotificationResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [NotificationResolverKeyedStringFilterItem!]
  ): ListNotificationsResponse!
  person(uuid: String!): GetPersonResponse!
  personByLinkBlue(linkBlueId: String!): GetPersonResponse!
  pointEntries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [PointEntryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [PointEntryResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: Void

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: Void
  ): ListPointEntriesResponse!
  pointEntry(uuid: String!): GetPointEntryByUuidResponse!
  pointOpportunities(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [PointOpportunityResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [PointOpportunityResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [PointOpportunityResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [PointOpportunityResolverKeyedStringFilterItem!]
  ): ListPointOpportunitiesResponse!
  pointOpportunity(uuid: String!): SinglePointOpportunityResponse!
  searchPeopleByName(name: String!): GetPeopleResponse!
  team(uuid: String!): SingleTeamResponse!
  teams(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: Void

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean @deprecated(reason: "Soft-deletion is no longer used in this project, this parameter is ignored")

    """The is-null filters to apply to the query"""
    isNullFilters: [TeamResolverKeyedIsNullFilterItem!]
    legacyStatus: [TeamLegacyStatus!]
    marathonYear: [String!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [TeamResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [TeamResolverKeyedStringFilterItem!]
    type: [TeamType!]
    visibility: [DbRole!] @deprecated(reason: "Use type")
  ): ListTeamsResponse!
}

input RegisterDeviceInput {
  deviceId: String!

  """The Expo push token of the device"""
  expoPushToken: String

  """The ID of the last user to log in on this device"""
  lastUserId: String

  """base64 encoded SHA-256 hash of a secret known to the device"""
  verifier: String!
}

type RegisterDeviceResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: DeviceNode!
  ok: Boolean!
}

type RemoveEventImageResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

type ScheduleNotificationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

type SendNotificationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

input SetEventInput {
  description: String
  location: String
  occurrences: [SetEventOccurrenceInput!]!
  summary: String
  title: String!
}

input SetEventOccurrenceInput {
  fullDay: Boolean!
  interval: IntervalISOInput!

  """
  If updating an existing occurrence, the UUID of the occurrence to update
  """
  uuid: String
}

type SetEventResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: EventNode!
  ok: Boolean!
}

input SetFeedInput {
  textContent: String
  title: String!
}

input SetMarathonHourInput {
  details: String
  durationInfo: String!
  shownStartingAt: DateTimeISO!
  title: String!
}

input SetMarathonInput {
  endDate: DateTimeISO!
  startDate: DateTimeISO!
  year: String!
}

input SetPersonInput {
  captainOf: [String!]
  dbRole: DbRole
  email: EmailAddress
  linkblue: String
  memberOf: [String!]
  name: String
}

input SetPointOpportunityInput {
  eventUuid: ID
  name: String
  opportunityDate: DateTimeISO
  type: TeamType
}

input SetTeamInput {
  legacyStatus: TeamLegacyStatus
  marathonYear: String
  name: String
  persistentIdentifier: String
  type: TeamType
}

type SinglePointOpportunityResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointOpportunityNode!
  ok: Boolean!
}

type SingleTeamResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: TeamNode!
  ok: Boolean!
}

enum SortDirection {
  ASCENDING
  DESCENDING
}

type StageNotificationResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: NotificationNode!
  ok: Boolean!
  uuid: String!
}

enum StringComparator {
  ENDS_WITH
  EQUALS
  IS
  STARTS_WITH
  SUBSTRING
}

"""New Team vs Returning Team"""
enum TeamLegacyStatus {
  DemoTeam
  NewTeam
  ReturningTeam
}

type TeamNode implements Node {
  captains: [MembershipNode!]! @deprecated(reason: "Just query the members field and filter by role")
  createdAt: DateTimeISO
  id: ID!
  legacyStatus: TeamLegacyStatus!
  marathon: MarathonNode!
  members: [MembershipNode!]!
  name: String!
  pointEntries: [PointEntryNode!]!
  totalPoints: Int!
  type: TeamType!
  updatedAt: DateTimeISO
}

enum TeamResolverAllKeys {
  legacyStatus
  marathonYear
  name
  type
}

input TeamResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: TeamResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input TeamResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: TeamResolverOneOfFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input TeamResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: TeamResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum TeamResolverOneOfFilterKeys {
  legacyStatus
  marathonYear
  type
}

enum TeamResolverStringFilterKeys {
  name
}

"""Types of teams"""
enum TeamType {
  Committee
  Morale
  Spirit
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

"""Represents NULL values"""
scalar Void