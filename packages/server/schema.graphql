# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

"""API response"""
interface AbstractGraphQLArrayOkResponse implements GraphQLBaseResponse {
  ok: Boolean!
}

"""API response"""
interface AbstractGraphQLCreatedResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
  uuid: String!
}

"""API response"""
interface AbstractGraphQLOkResponse implements GraphQLBaseResponse {
  ok: Boolean!
}

"""API response"""
interface AbstractGraphQLPaginatedResponse implements AbstractGraphQLArrayOkResponse & GraphQLBaseResponse {
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

input AddEventImageInput {
  alt: String
  height: Int!
  imageData: String
  mimeType: String!
  thumbHash: String
  url: String
  width: Int!
}

type AddEventImageResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ImageResource!
  ok: Boolean!
}

type AuthIdList {
  source: AuthSource!
  value: String!
}

"""The source of authentication"""
enum AuthSource {
  Anonymous
  None
  UkyLinkblue
}

"""The identifier for a committee"""
enum CommitteeIdentifier {
  communityDevelopmentCommittee
  corporateCommittee
  dancerRelationsCommittee
  familyRelationsCommittee
  fundraisingCommittee
  marketingCommittee
  miniMarathonsCommittee
  operationsCommittee
  programmingCommittee
  techCommittee
}

"""Roles within a committee"""
enum CommitteeRole {
  Chair
  Coordinator
  Member
}

type ConfigurationResource {
  createdAt: DateTimeISO
  key: String!
  updatedAt: DateTimeISO
}

input CreateConfigurationInput {
  key: String!
}

type CreateConfigurationResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ConfigurationResource!
  ok: Boolean!
  uuid: String!
}

input CreateDeviceInput {
  deviceId: String!

  """The Expo push token of the device"""
  expoPushToken: String

  """The ID of the last user to log in on this device"""
  lastUserId: String
}

type CreateDeviceResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: DeviceResource!
  ok: Boolean!
  uuid: String!
}

input CreateEventInput {
  description: String
  location: String
  occurrences: [CreateEventOccurrenceInput!]!
  summary: String
  title: String!
}

input CreateEventOccurrenceInput {
  fullDay: Boolean!
  interval: LuxonDateRange!
}

type CreateEventResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: EventResource!
  ok: Boolean!
  uuid: String!
}

input CreateImageInput {
  alt: String
  height: NonNegativeInt!
  imageData: String
  mimeType: String!
  thumbHash: String
  url: String
  width: NonNegativeInt!
}

type CreateImageResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ImageResource!
  ok: Boolean!
  uuid: String!
}

input CreatePersonInput {
  captainOf: [String!]! = []
  email: EmailAddress!
  linkblue: String
  memberOf: [String!]! = []
  name: String
  role: RoleResourceInput
}

type CreatePersonResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PersonResource!
  ok: Boolean!
  uuid: String!
}

input CreatePointEntryInput {
  comment: String
  opportunityUuid: String
  personFromUuid: String
  points: Float!
  teamUuid: String!
}

type CreatePointEntryResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointEntryResource!
  ok: Boolean!
  uuid: String!
}

input CreatePointOpportunityInput {
  eventUuid: ID
  name: String!
  opportunityDate: LuxonDateTime
  type: TeamType!
}

type CreatePointOpportunityResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointOpportunityResource!
  ok: Boolean!
  uuid: String!
}

input CreateTeamInput {
  legacyStatus: TeamLegacyStatus!
  marathonYear: String!
  name: String!
  persistentIdentifier: String
  type: TeamType!
}

type CreateTeamResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: TeamResource!
  ok: Boolean!
  uuid: String!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

"""DanceBlue roles"""
enum DbRole {
  Committee
  None
  Public
  TeamCaptain
  TeamMember
}

type DeleteConfigurationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteDeviceResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteEventResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteImageResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteNotificationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeletePersonResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeletePointEntryResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeletePointOpportunityResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

type DeleteTeamResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  ok: Boolean!
}

enum DeviceResolverAllKeys {
  createdAt
  deviceId
  expoPushToken
  lastLogin
  updatedAt
}

enum DeviceResolverDateFilterKeys {
  createdAt
  lastLogin
  updatedAt
}

input DeviceResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: DeviceResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: LuxonDateTime!
}

input DeviceResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: DeviceResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input DeviceResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: DeviceResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input DeviceResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: DeviceResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum DeviceResolverStringFilterKeys {
  deviceId
  expoPushToken
}

type DeviceResource {
  createdAt: DateTimeISO
  expoPushToken: String
  lastLoggedInUser: PersonResource
  lastLogin: LuxonDateTime
  updatedAt: DateTimeISO
  uuid: ID!
}

"""
A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address.
"""
scalar EmailAddress @specifiedBy(url: "https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address")

type EventOccurrenceResource {
  createdAt: DateTimeISO
  fullDay: Boolean!
  interval: LuxonDateRange!
  updatedAt: DateTimeISO
  uuid: ID!
}

enum EventResolverAllKeys {
  createdAt
  description
  duration
  location
  occurrence
  summary
  title
  updatedAt
}

enum EventResolverDateFilterKeys {
  createdAt
  occurrence
  updatedAt
}

input EventResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: EventResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: LuxonDateTime!
}

input EventResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: EventResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input EventResolverKeyedNumericFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: EventResolverNumericFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: Float!
}

input EventResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: EventResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input EventResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: EventResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum EventResolverNumericFilterKeys {
  duration
}

enum EventResolverStringFilterKeys {
  description
  location
  summary
  title
}

type EventResource {
  createdAt: DateTimeISO
  description: String
  images: [ImageResource!]!
  location: String
  occurrences: [EventOccurrenceResource!]!
  summary: String
  title: String!
  updatedAt: DateTimeISO
  uuid: ID!
}

type GetAllConfigurationsResponse implements AbstractGraphQLArrayOkResponse & GraphQLBaseResponse {
  data: ConfigurationResource!
  ok: Boolean!
}

type GetConfigurationByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ConfigurationResource!
  ok: Boolean!
}

type GetDeviceByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: DeviceResource!
  ok: Boolean!
}

type GetEventByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: EventResource!
  ok: Boolean!
}

type GetImageByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ImageResource!
  ok: Boolean!
}

type GetNotificationByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: NotificationResource!
  ok: Boolean!
}

type GetPeopleResponse implements AbstractGraphQLArrayOkResponse & GraphQLBaseResponse {
  data: [PersonResource!]!
  ok: Boolean!
}

type GetPersonResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PersonResource
  ok: Boolean!
}

type GetPointEntryByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointEntryResource!
  ok: Boolean!
}

type GetThumbHashByUuidResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: String!
  ok: Boolean!
}

"""API response"""
interface GraphQLBaseResponse {
  ok: Boolean!
}

type ImageResource {
  alt: String
  createdAt: DateTimeISO
  height: Int!
  imageData: String
  mimeType: String!
  thumbHash: String
  updatedAt: DateTimeISO
  url: URL
  uuid: ID!
  width: Int!
}

type ListDevicesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [DeviceResource!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListEventsResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [EventResource!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListNotificationsResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [NotificationResource!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPeopleResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [PersonResource!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPointEntriesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [PointEntryResource!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListPointOpportunitiesResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [PointOpportunityResource!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type ListTeamsResponse implements AbstractGraphQLArrayOkResponse & AbstractGraphQLPaginatedResponse & GraphQLBaseResponse {
  data: [TeamResource!]!
  ok: Boolean!

  """The current page number (1-indexed)"""
  page: PositiveInt!

  """The number of items per page"""
  pageSize: NonNegativeInt!

  """The total number of items"""
  total: NonNegativeInt!
}

type LoginState {
  authSource: AuthSource!
  loggedIn: Boolean!
  role: RoleResource!
}

"""Date range custom scalar type (just an ISO 8601 interval)"""
scalar LuxonDateRange @specifiedBy(url: "https://www.iso.org/iso-8601-date-and-time-format.html")

"""Luxon DateTime custom scalar type"""
scalar LuxonDateTime

"""The position of a member on a team"""
enum MembershipPositionType {
  Captain
  Member
}

type MembershipResource {
  createdAt: DateTimeISO
  person: PersonResource!
  position: MembershipPositionType!
  team: TeamResource!
  updatedAt: DateTimeISO
  uuid: ID!
}

type Mutation {
  addExistingImageToEvent(eventId: String!, imageId: String!): AddEventImageResponse!
  addImageToEvent(eventId: String!, input: AddEventImageInput!): AddEventImageResponse!
  createConfiguration(input: CreateConfigurationInput!): CreateConfigurationResponse!
  createDevice(input: CreateDeviceInput!): CreateDeviceResponse!
  createEvent(input: CreateEventInput!): CreateEventResponse!
  createImage(input: CreateImageInput!): CreateImageResponse!
  createPerson(input: CreatePersonInput!): CreatePersonResponse!
  createPointEntry(input: CreatePointEntryInput!): CreatePointEntryResponse!
  createPointOpportunity(input: CreatePointOpportunityInput!): CreatePointOpportunityResponse!
  createTeam(input: CreateTeamInput!): CreateTeamResponse!
  deleteConfiguration(uuid: String!): DeleteConfigurationResponse!
  deleteDevice(uuid: String!): DeleteDeviceResponse!
  deleteEvent(uuid: String!): DeleteEventResponse!
  deleteImage(uuid: String!): DeleteImageResponse!
  deleteNotification(uuid: String!): DeleteNotificationResponse!
  deletePerson(uuid: String!): DeletePersonResponse!
  deletePointEntry(uuid: String!): DeletePointEntryResponse!
  deletePointOpportunity(uuid: String!): DeletePointOpportunityResponse!
  deleteTeam(uuid: String!): DeleteTeamResponse!
  removeImageFromEvent(eventId: String!, imageId: String!): RemoveEventImageResponse!
  sendNotification(input: SendNotificationInput!): SendNotificationResponse!
  setConfiguration(input: SetConfigurationInput!, key: String!): SetConfigurationResponse!
  setEvent(input: SetEventInput!, uuid: String!): SetEventResponse!
  setPerson(input: SetPersonInput!, uuid: String!): GetPersonResponse!
  setPointOpportunity(input: SetPointOpportunityInput!, uuid: String!): SinglePointOpportunityResponse!
  setTeam(input: SetTeamInput!, uuid: String!): SingleTeamResponse!
}

"""Integers that will have a value of 0 or more."""
scalar NonNegativeInt

type NotificationPayload {
  """
  Only shown for presentation type INFO_POPUP, shown at the bottom of the popup
  """
  message: String
  presentation: NotificationPayloadPresentationType!

  """
  A title for the notification, ignored for presentation type URL, shown with the webview for presentation type IN_APP_VIEW, and shown at the top of the popup for presentation type INFO_POPUP
  """
  title: String

  """
  A URL related to the notification, opened immediately for presentation type URL, opened in a webview for presentation type IN_APP_VIEW, and shown as a button for presentation type INFO_POPUP
  """
  url: String
}

"""
The type of presentation for the notification, URL skips the app and opens a URL directly, IN_APP_VIEW opens a webview, and INFO_POPUP shows a popup
"""
enum NotificationPayloadPresentationType {
  INFO_POPUP
  IN_APP_VIEW
  OPEN_URL
}

enum NotificationResolverAllKeys {
  uuid
}

input NotificationResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: NotificationResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

type NotificationResource {
  body: String!
  createdAt: DateTimeISO
  payload: NotificationPayload
  sendTime: DateTimeISO!
  sound: String
  title: String!
  updatedAt: DateTimeISO
  uuid: ID!
}

enum NumericComparator {
  EQUALS
  GREATER_THAN
  GREATER_THAN_OR_EQUAL_TO
  IS
  LESS_THAN
  LESS_THAN_OR_EQUAL_TO
}

enum PersonResolverAllKeys {
  committeeName
  committeeRole
  dbRole
  email
  linkblue
  name
}

input PersonResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PersonResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input PersonResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: PersonResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input PersonResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: PersonResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum PersonResolverStringFilterKeys {
  committeeName
  committeeRole
  dbRole
  email
  linkblue
  name
}

type PersonResource {
  authIds: [AuthIdList!]!
  captaincies: [MembershipResource!]!
  createdAt: DateTimeISO
  email: String!
  linkblue: String
  name: String
  role: RoleResource!
  teams: [MembershipResource!]!
  updatedAt: DateTimeISO
  uuid: ID!
}

enum PointEntryResolverAllKeys {
  createdAt
  updatedAt
}

enum PointEntryResolverDateFilterKeys {
  createdAt
  updatedAt
}

input PointEntryResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: PointEntryResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: LuxonDateTime!
}

input PointEntryResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PointEntryResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

type PointEntryResource {
  comment: String
  createdAt: DateTimeISO
  personFrom: PersonResource
  pointOpportunity: PointOpportunityResource
  points: Int!
  team: TeamResource!
  updatedAt: DateTimeISO
  uuid: ID!
}

enum PointOpportunityResolverAllKeys {
  createdAt
  name
  opportunityDate
  type
  updatedAt
}

enum PointOpportunityResolverDateFilterKeys {
  createdAt
  opportunityDate
  updatedAt
}

input PointOpportunityResolverKeyedDateFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: PointOpportunityResolverDateFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: LuxonDateTime!
}

input PointOpportunityResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: PointOpportunityResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input PointOpportunityResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: PointOpportunityResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input PointOpportunityResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: PointOpportunityResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum PointOpportunityResolverStringFilterKeys {
  name
  type
}

type PointOpportunityResource {
  createdAt: DateTimeISO
  event: EventResource
  name: String!
  opportunityDate: LuxonDateTime
  type: TeamType!
  updatedAt: DateTimeISO
  uuid: ID!
}

"""Integers that will have a value greater than 0."""
scalar PositiveInt

type Query {
  allConfigurations: GetAllConfigurationsResponse!
  configuration(key: String!): GetConfigurationByUuidResponse!
  device(uuid: String!): GetDeviceByUuidResponse!
  devices(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [DeviceResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean

    """The is-null filters to apply to the query"""
    isNullFilters: [DeviceResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [DeviceResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [DeviceResolverKeyedStringFilterItem!]
  ): ListDevicesResponse!
  event(uuid: String!): GetEventByUuidResponse!
  events(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [EventResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean

    """The is-null filters to apply to the query"""
    isNullFilters: [EventResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: [EventResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [EventResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [EventResolverKeyedStringFilterItem!]
  ): ListEventsResponse!
  image(uuid: String!): GetImageByUuidResponse!
  listPeople(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: Void

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean

    """The is-null filters to apply to the query"""
    isNullFilters: [PersonResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [PersonResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [PersonResolverKeyedStringFilterItem!]
  ): ListPeopleResponse!
  loginState: LoginState!
  me: GetPersonResponse!
  notification(uuid: String!): GetNotificationByUuidResponse!
  notifications(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: Void

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean

    """The is-null filters to apply to the query"""
    isNullFilters: [NotificationResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: Void

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: Void
  ): ListNotificationsResponse!
  person(uuid: String!): GetPersonResponse!
  personByLinkBlue(linkBlueId: String!): GetPersonResponse!
  pointEntries(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [PointEntryResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean

    """The is-null filters to apply to the query"""
    isNullFilters: [PointEntryResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: Void

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: Void
  ): ListPointEntriesResponse!
  pointEntry(uuid: String!): GetPointEntryByUuidResponse!
  pointOpportunities(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: [PointOpportunityResolverKeyedDateFilterItem!]

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean

    """The is-null filters to apply to the query"""
    isNullFilters: [PointOpportunityResolverKeyedIsNullFilterItem!]

    """The numeric filters to apply to the query"""
    numericFilters: Void

    """The one-of filters to apply to the query"""
    oneOfFilters: [PointOpportunityResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [PointOpportunityResolverKeyedStringFilterItem!]
  ): ListPointOpportunitiesResponse!
  pointOpportunity(uuid: String!): SinglePointOpportunityResponse!
  searchPeopleByName(name: String!): GetPeopleResponse!
  team(uuid: String!): SingleTeamResponse!
  teams(
    """The boolean filters to apply to the query"""
    booleanFilters: Void

    """The date filters to apply to the query"""
    dateFilters: Void

    """Whether to include deleted items in the results"""
    includeDeleted: Boolean

    """The is-null filters to apply to the query"""
    isNullFilters: [TeamResolverKeyedIsNullFilterItem!]
    legacyStatus: [TeamLegacyStatus!]
    marathonYear: [String!]

    """The numeric filters to apply to the query"""
    numericFilters: [TeamResolverKeyedNumericFilterItem!]

    """The one-of filters to apply to the query"""
    oneOfFilters: [TeamResolverKeyedOneOfFilterItem!]

    """The page number to return, defaults to 1"""
    page: Int

    """The number of items to return per page, defaults to 10"""
    pageSize: Int

    """
    Whether to send all results in a single page, defaults to false (should generally be avoided)
    """
    sendAll: Boolean

    """
    The fields to sort by, in order of priority. If unspecified, the sort order is undefined
    """
    sortBy: [String!]

    """
    The direction to sort, if not specified will default to ascending, the order of the values in this array should match the order of the values in the sortBy array, if only one value is specified it will be used for all sortBy values, otherwise the lengths must match
    """
    sortDirection: [SortDirection!]

    """The string filters to apply to the query"""
    stringFilters: [TeamResolverKeyedStringFilterItem!]
    type: [TeamType!]
    visibility: [DbRole!]
  ): ListTeamsResponse!
  thumbhash(uuid: String!): GetThumbHashByUuidResponse
}

type RemoveEventImageResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: Boolean!
  ok: Boolean!
}

type RoleResource {
  committeeIdentifier: CommitteeIdentifier
  committeeRole: CommitteeRole
  createdAt: DateTimeISO
  dbRole: DbRole!
  updatedAt: DateTimeISO
}

input RoleResourceInput {
  committeeIdentifier: CommitteeIdentifier
  committeeRole: CommitteeRole
  dbRole: DbRole! = None
}

input SendNotificationInput {
  body: String!
  title: String!
}

type SendNotificationResponse implements AbstractGraphQLCreatedResponse & AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: NotificationResource!
  ok: Boolean!
  uuid: String!
}

input SetConfigurationInput {
  key: String!
}

type SetConfigurationResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: ConfigurationResource!
  ok: Boolean!
}

input SetEventInput {
  description: String
  location: String
  occurrences: [SetEventOccurrenceInput!]!
  summary: String
  title: String!
}

input SetEventOccurrenceInput {
  fullDay: Boolean!
  interval: LuxonDateRange!

  """
  If updating an existing occurrence, the UUID of the occurrence to update
  """
  uuid: String
}

type SetEventResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: EventResource!
  ok: Boolean!
}

input SetPersonInput {
  captainOf: [String!]
  email: EmailAddress
  linkblue: String
  memberOf: [String!]
  name: String
  role: RoleResourceInput
}

input SetPointOpportunityInput {
  eventUuid: ID
  name: String
  opportunityDate: LuxonDateTime
  type: TeamType
}

input SetTeamInput {
  legacyStatus: TeamLegacyStatus
  marathonYear: String
  name: String
  persistentIdentifier: String
  type: TeamType
}

type SinglePointOpportunityResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: PointOpportunityResource!
  ok: Boolean!
}

type SingleTeamResponse implements AbstractGraphQLOkResponse & GraphQLBaseResponse {
  data: TeamResource!
  ok: Boolean!
}

enum SortDirection {
  ASCENDING
  DESCENDING
}

enum StringComparator {
  ENDS_WITH
  EQUALS
  ILIKE
  IREGEX
  IS
  LIKE
  REGEX
  STARTS_WITH
  SUBSTRING
}

"""New Team vs Returning Team"""
enum TeamLegacyStatus {
  NewTeam
  ReturningTeam
}

enum TeamResolverAllKeys {
  legacyStatus
  marathonYear
  name
  totalPoints
  type
}

input TeamResolverKeyedIsNullFilterItem {
  """The field to filter on"""
  field: TeamResolverAllKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
}

input TeamResolverKeyedNumericFilterItem {
  """The comparator to use for the filter"""
  comparison: NumericComparator!

  """The field to filter on"""
  field: TeamResolverNumericFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: Float!
}

input TeamResolverKeyedOneOfFilterItem {
  """The field to filter on"""
  field: TeamResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: [String!]!
}

input TeamResolverKeyedStringFilterItem {
  """The comparator to use for the filter"""
  comparison: StringComparator!

  """The field to filter on"""
  field: TeamResolverStringFilterKeys!

  """
  Should the comparator be negated? WARNING: This will throw if used on a comparator that does not support negation.
  """
  negate: Boolean = false
  value: String!
}

enum TeamResolverNumericFilterKeys {
  totalPoints
}

enum TeamResolverStringFilterKeys {
  legacyStatus
  marathonYear
  name
  type
}

type TeamResource {
  captains: [MembershipResource!]!
  createdAt: DateTimeISO
  legacyStatus: TeamLegacyStatus!
  marathonYear: String!
  members: [MembershipResource!]!
  name: String!
  persistentIdentifier: String
  pointEntries: [PointEntryResource!]!
  totalPoints: Int!
  type: TeamType!
  updatedAt: DateTimeISO
  uuid: ID!
}

"""Types of teams"""
enum TeamType {
  Committee
  Morale
  Spirit
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

"""Represents NULL values"""
scalar Void