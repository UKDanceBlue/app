# Custom Scalars

"""
A cursor for use in paginating through collections of data. Cursors are opaque strings that are
intended to be used by clients to paginate through a connection. Clients should not attempt to
destructure or parse the cursor string, as the format may change at any time.
"""
scalar Cursor

"""
This is a special scalar that is used to represent the unique identifier of a node. It is serialized
as a string and parsed from a string. It is guaranteed to be unique across all nodes in the system,
and is used to identify nodes in the Relay specification. For the purposes of this schema, it is
an opaque string that can be used to identify a node. The client should never attempt to parse or
destructure this value, as the format may change at any time.
"""
scalar NodeID

# GraphQL Scalars

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format
outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates
and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and
parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

"""
A string representing a duration conforming to the ISO8601 standard, such as P1W1DT13H23M34S.
"""
scalar Duration

"""
A field whose value conforms to the standard internet email address format as specified in HTML
Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address.
"""
scalar EmailAddress
  @specifiedBy(
    url: "https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address"
  )

"""
Integers that will have a value of 0 or more.
"""
scalar NonNegativeInt

"""
Integers that will have a value greater than 0.
"""
scalar PositiveInt

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

"""
Represents NULL values
"""
scalar Void

scalar UUID

# Enums

"""
The source of authentication
"""
enum AuthSource {
  Anonymous
  Demo
  LinkBlue
  None
}

"""
Roles within a committee
"""
enum CommitteeRole {
  Chair
  Coordinator
  Member
}

"""
DanceBlue roles
"""
enum DbRole {
  Committee
  None
  Public
  UKY
}

"""
The position of a member on a team
"""
enum MembershipPositionType {
  Captain
  Member
}

enum SortDirection {
  ASCENDING
  DESCENDING
}

"""
New Team vs Returning Team
"""
enum TeamLegacyStatus {
  DemoTeam
  NewTeam
  ReturningTeam
}

"""
Types of teams
"""
enum PointType {
  Morale
  Spirit
}

enum ErrorCode {
  INTERNAL_ERROR
}

"""
All the tabs the app can show
"""
enum MobileAppTab {
  Home
  Events
  Explore
  Teams
  Marathon
  DBMoments
  Info
}

# Re-used Types

type PageInfo {
  """
  hasPreviousPage is used to indicate whether more edges exist prior to the set defined by the
  clients arguments. If the client is paginating with last/before, then the server must return
  true if prior edges exist, otherwise false. If the client is paginating with first/after,
  then the client may return true if edges prior to after exist, if it can do so efficiently,
  otherwise may return false.
  """
  hasPreviousPage: Boolean!
  """
  hasNextPage is used to indicate whether more edges exist following the set defined by the clients
  arguments. If the client is paginating with first/after, then the server must return true if
  further edges exist, otherwise false. If the client is paginating with last/before, then the
  client may return true if edges further from before exist, if it can do so efficiently, otherwise
  may return false.
  """
  hasNextPage: Boolean!
  """
  startCursor is simply an opaque value that refers to the first position in a connection. It is
  used by the client to request the first set of edges in a connection. The server must return
  the cursor that corresponds to the first element in the connection.
  """
  startCursor: Cursor
  """
  endCursor is simply an opaque value that refers to the last position in a connection. It is
  used by the client to request the last set of edges in a connection. The server must return
  the cursor that corresponds to the last element in the connection.
  """
  endCursor: Cursor
}

type Error {
  """
  A specific error code to identify the error
  """
  code: ErrorCode!
  """
  A human readable error message
  """
  message: String!
  """
  A message that should be presented to the user
  """
  alert: String
  """
  Development information about the error. should not be sent to untrusted clients (i.e. production environments)
  """
  debugInfo: String
}

type IntervalISO {
  """
  The beginning of the interval
  """
  start: DateTimeISO!
  """
  The end of the interval
  """
  end: DateTimeISO!

  """
  The ISO formatted interval
  """
  iso8601: String

  """
  The duration of the interval
  """
  duration: Duration

  """
  Whether the interval is empty, meaning the start and end are the same
  """
  isEmpty: Boolean
}

# Interfaces

interface Node {
  id: NodeID!
}

interface Edge {
  cursor: Cursor!
  node: Node!
}

interface Errorable {
  errors: [Error!]!
}

interface Connection implements Errorable {
  totalCount: NonNegativeInt!
  edges: [Edge!]!
  pageInfo: PageInfo!
  errors: [Error!]!
}

interface Resource implements Errorable {
  node: Node!
  errors: [Error!]!
}

interface Result implements Errorable {
  node: Node
  errors: [Error!]!
}

# Resources

type Configuration {
  uuid: UUID!

  key: String!
  value: String!
  validAfter: DateTimeISO
  validUntil: DateTimeISO

  setBy: Person

  updatedAt: DateTimeISO
  createdAt: DateTimeISO
}

type MobileAppConfiguration {
  shownTabs: [MobileAppTab!]!
  fancyTab: MobileAppTab
  allowedLoginTypes: [AuthSource!]!
}

type Device {
  uuid: UUID!

  lastLoggedInUser: Person
  lastLogin: DateTimeISO
  notificationDeliveries(
    page: PositiveInt = 1
    pageSize: NonNegativeInt = 10
  ): [NotificationDelivery!]!

  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type Event {
  uuid: UUID!

  title: String!
  summary: String
  description: String
  images: [Image!]!
  location: String
  occurrences: [IntervalISO!]!

  updatedBy: Person
  updatedAt: DateTimeISO
  createdBy: Person
  createdAt: DateTimeISO
}

type Feed {
  uuid: UUID!

  title: String!
  image: Image
  textContent: String

  updatedBy: Person
  updatedAt: DateTimeISO
  createdBy: Person
  createdAt: DateTimeISO
}

type Image {
  uuid: UUID!

  url: URL
  alt: String
  mimeType: String!
  thumbHash: String
  height: NonNegativeInt!
  width: NonNegativeInt!

  updatedBy: Person
  updatedAt: DateTimeISO
  createdBy: Person
  createdAt: DateTimeISO
}

"""
Describes a set of teams whose points are compared
"""
type Leaderboard {
  uuid: UUID!

  """
  An ordered list of teams
  """
  teams: [Team!]!

  # The filters applied to this leaderboard
  legacyStatus: TeamLegacyStatus
  """
  If true: only committee teams are included, if false: only non-committee teams are included, if null: all teams are included
  """
  committee: Boolean
  pointType: PointType!

  """
  A short user-friendly description of the leaderboard
  """
  description: String
}

type MarathonHour {
  uuid: UUID!

  title: String!
  details: String
  durationInfo: String!

  shownStartingAt: DateTimeISO!

  updatedBy: Person
  createdAt: DateTimeISO
  createdBy: Person
  updatedAt: DateTimeISO
}

type Marathon {
  uuid: UUID!

  hours: [MarathonHour!]!

  """
  A four digit year
  """
  year: String!
  interval: IntervalISO!

  allSpiritTeamsLeaderboard: Leaderboard!
  returningSpiritTeamsLeaderboard: Leaderboard!
  newSpiritTeamsLeaderboard: Leaderboard!
  committeeSpiritTeamsLeaderboard: Leaderboard!
  nonCommitteeSpiritTeamsLeaderboard: Leaderboard!
  moraleLeaderboard: Leaderboard!

  communityDevelopmentCommittee: Committee!
  corporateCommittee: Committee!
  dancerRelationsCommittee: Committee!
  familyRelationsCommittee: Committee!
  fundraisingCommittee: Committee!
  marketingCommittee: Committee!
  miniMarathonsCommittee: Committee!
  operationsCommittee: Committee!
  programmingCommittee: Committee!
  techCommittee: Committee!
  viceCommittee: Committee!
  overallCommittee: Committee!

  teams: [Team!]!

  updatedBy: Person
  createdAt: DateTimeISO
  createdBy: Person
  updatedAt: DateTimeISO
}

type Membership {
  uuid: UUID!

  person: Person!
  team: Team!

  position: MembershipPositionType!

  updatedBy: Person
  createdAt: DateTimeISO
  createdBy: Person
  updatedAt: DateTimeISO
}

type NotificationDelivery {
  uuid: UUID!

  notification: Notification!

  """
  A unique identifier corresponding the group of notifications this was sent to Expo with.
  """
  chunkUuid: String

  """
  Any error message returned by Expo when sending the notification.
  """
  deliveryError: String

  """
  The time the server received a delivery receipt from the user.
  """
  receiptCheckedAt: DateTimeISO

  """
  The time the server sent the notification to Expo for delivery.
  """
  sentAt: DateTimeISO

  updatedAt: DateTimeISO
  createdAt: DateTimeISO
}

type Notification {
  uuid: UUID!

  title: String!
  body: String!

  sentBy: Person
  """
  The time the notification is scheduled to be sent, if null it is either already sent or unscheduled.
  """
  sendAt: DateTimeISO

  """
  The time the server started sending the notification.
  """
  startedSendingAt: DateTimeISO
  url: URL

  deliveryCount: NonNegativeInt!
  deliveryIssue: String
  deliveryIssueAcknowledgedAt: DateTimeISO
  deliveryIssueCount: NonNegativeInt!

  updatedBy: Person
  createdAt: DateTimeISO
  createdBy: Person
  updatedAt: DateTimeISO
}

type Person {
  uuid: UUID!

  role: Role!
  teams: [Membership!]!
  primaryCommittee: Committee
  committees: [Committee!]!

  name: String
  email: String!
  linkblue: String

  updatedBy: Person
  updatedAt: DateTimeISO
  createdBy: Person
  createdAt: DateTimeISO
}

type PointEntry {
  uuid: UUID!

  personFrom: Person
  team: Team!

  comment: String
  pointOpportunity: PointOpportunity
  points: NonNegativeInt!

  updatedBy: Person
  updatedAt: DateTimeISO
  createdBy: Person
  createdAt: DateTimeISO
}

type PointOpportunity {
  uuid: UUID!

  event: Event

  marathon: Marathon!

  name: String!
  opportunityDate: DateTimeISO
  type: PointType!

  updatedBy: Person
  updatedAt: DateTimeISO
  createdBy: Person
  createdAt: DateTimeISO
}

type Role {
  committee: Committee
  committeeRole: CommitteeRole
  dbRole: DbRole!
}

type Team {
  uuid: UUID!

  members: [Membership!]!
  pointEntries: [PointEntry!]!

  marathon: Marathon!

  legacyStatus: TeamLegacyStatus!
  type: PointType!
  name: String!
  totalPoints: NonNegativeInt!

  updatedBy: Person
  updatedAt: DateTimeISO
  createdBy: Person
  createdAt: DateTimeISO
}

type Committee {
  uuid: UUID!

  team: Team!

  chairs: [Person!]!
  coordinators: [Person!]!
  members: [Person!]!
  allMembers: [Person!]!

  parentCommittee: Committee
  subCommittees: [Committee!]!

  updatedBy: Person
  updatedAt: DateTimeISO
  createdBy: Person
  createdAt: DateTimeISO
}
